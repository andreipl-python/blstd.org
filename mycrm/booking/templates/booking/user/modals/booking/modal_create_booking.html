{% load custom_filters %}
{% load static %}

<head>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
</head>
<!-- Модальное окно создания брони -->
<p id="tariff_units_json" style="display: none;">{{ tariff_units_json }}</p>
<p id="services_json" style="display: none;">{{ services_json }}</p>
<p id="clients_json" style="display: none;">{{ clients_json }}</p>

<div class="modal fade" id="createBookingModal" tabindex="-1" aria-labelledby="createBookingModalLabel"
    aria-hidden="true" data-bs-backdrop="false">
    <div class="modal-dialog modal-dialog-centered" style="max-width:none; width: 63vw;">
        <div class="modal-content">
            <div class="modal-body">
                <form id="bookingForm" action="javascript:void(0);" method="POST">
                    {% csrf_token %}
                    <div class="mb-3">
                        <div class="row d-flex align-items-center mb-1">
                            <div class="col-md-12 d-flex justify-content-between align-items-center">
                                <h2 class="mb-0">Новая бронь</h2>
                                <button type="button" class="modal-close-icon" data-bs-dismiss="modal"
                                    aria-label="Закрыть">
                                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                                        xmlns="http://www.w3.org/2000/svg">
                                        <path d="M18 6L6 18" stroke="#7A52FF" stroke-width="2" stroke-linecap="round"
                                            stroke-linejoin="round" />
                                        <path d="M6 6L18 18" stroke="#7A52FF" stroke-width="2" stroke-linecap="round"
                                            stroke-linejoin="round" />
                                    </svg>
                                </button>
                            </div>
                        </div>
                        <div class="row mb-4">
                            <div id="roomNameContainer" class="col-md-6 align-items-center justify-content-start">
                                <span id="scenarioName">Название сценария</span> / <span id="roomName">Название
                                    комнаты</span>
                            </div>
                        </div>


                        <input type="hidden" id="dateField" name="date">
                        <input type="hidden" id="timeField" name="time">
                        <input type="hidden" id="roomNameField" name="room_name">
                        <input type="hidden" id="maxEndTime" name="maxEndTime">
                        <input type="hidden" id="fullDatetimeField" name="full_datetime">
                        <input type="hidden" id="roomIdField" name="room_id">
                    </div>

                    <div class="row mb-3">
                        <!--Выпадающий список "Клиент"-->
                        <div class="col-md-6">
                            <label for="client" class="form-label">Клиент</label>
                            <div class="custom-select" id="client" name="client">
                                <span class="selected">Выберите клиента</span>
                                <span class="chevron">
                                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                                        xmlns="http://www.w3.org/2000/svg">
                                        <path d="M6 9L12 15L18 9" stroke="#818EA2" stroke-width="2" />
                                    </svg>
                                </span>
                                <ul class="options">
                                    <li id="search-option" class="search-option" style="cursor:text;">
                                        <span style="display:flex;align-items:center;gap:6px;">
                                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                                                xmlns="http://www.w3.org/2000/svg">
                                                <path
                                                    d="M11 19C15.4183 19 19 15.4183 19 11C19 6.58172 15.4183 3 11 3C6.58172 3 3 6.58172 3 11C3 15.4183 6.58172 19 11 19Z"
                                                    stroke="#818EA2" stroke-width="2" stroke-linecap="round"
                                                    stroke-linejoin="round" />
                                                <path d="M21.0002 21L16.7002 16.7" stroke="#818EA2" stroke-width="2"
                                                    stroke-linecap="round" stroke-linejoin="round" />
                                            </svg>
                                            <input id="client-search-input" type="text" placeholder="Поиск"
                                                style="border:none;outline:none;background:transparent;width:120px;"
                                                autocomplete="off" />
                                        </span>
                                    </li>
                                    {% for client in clients %}
                                        <li data-value="{{ client.id }}">{{ client.name }}</li>
                                    {% endfor %}
                                </ul>
                            </div>
                        </div>

                        <!-- Выпадающий список "Направление" -->
                        <div class="col-md-6">
                            <label for="field-direction" class="form-label">Направление</label>
                            <div class="custom-select custom-select--clearable" id="field-direction" name="field-direction" data-placeholder="Выберите направление">
                                <span class="selected">Выберите направление</span>
                                <button type="button" class="custom-select-clear" aria-label="Сбросить выбор">×</button>
                                <span class="chevron">
                                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                                        xmlns="http://www.w3.org/2000/svg">
                                        <path d="M6 9L12 15L18 9" stroke="#818EA2" stroke-width="2" />
                                    </svg>
                                </span>
                                <ul class="options">
                                    {% for direction in directions %}
                                        <li data-value="{{ direction.id }}">{{ direction.name }}</li>
                                    {% endfor %}
                                </ul>
                            </div>
                        </div>
                    </div>

                    <div class="row mb-3">
                        <!--Строка информации об абонементе-->
                        <span id="abonementRow">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                                xmlns="http://www.w3.org/2000/svg">
                                <path
                                    d="M12.586 2.586C12.211 2.2109 11.7024 2.00011 11.172 2H4C3.46957 2 2.96086 2.21071 2.58579 2.58579C2.21071 2.96086 2 3.46957 2 4V11.172C2.00011 11.7024 2.2109 12.211 2.586 12.586L11.29 21.29C11.7445 21.7416 12.3592 21.9951 13 21.9951C13.6408 21.9951 14.2555 21.7416 14.71 21.29L21.29 14.71C21.7416 14.2555 21.9951 13.6408 21.9951 13C21.9951 12.3592 21.7416 11.7445 21.29 11.29L12.586 2.586Z"
                                    stroke="#EB5757" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                                <path
                                    d="M7.5 8C7.77614 8 8 7.77614 8 7.5C8 7.22386 7.77614 7 7.5 7C7.22386 7 7 7.22386 7 7.5C7 7.77614 7.22386 8 7.5 8Z"
                                    fill="#EB5757" stroke="#EB5757" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round" />
                            </svg>
                            <span>Aбонемент:</span>
                            <span>Название абонемента</span>
                            <span>/</span>
                            <span>Осталось занятий:</span>
                            <span>4</span>
                        </span>
                    </div>

                    <div class="row mb-3">
                        <!--Календарь дата-->
                        <div class="col-md-3">
                            <label for="modal-create-date" class="form-label">Дата</label>
                            <div id="custom-date-field" style="padding: 0; border: none; background: none;">
                                <input type="date" id="modal-create-date" name="modal-create-date"
                                    class="form-control" />
                            </div>
                        </div>

                        <!--Выпадающий список Время начала-->
                        <div class="col-md-3">
                            <label for="start-time" class="form-label">Время начала</label>
                            <div class="custom-select custom-select--clearable" id="start-time" name="start-time" data-placeholder="Выберите время">
                                <span class="selected">Выберите время</span>
                                <button type="button" class="custom-select-clear" aria-label="Сбросить выбор">×</button>
                                <!-- Значок предупреждения о недоступном слоте -->
                                <span id="start-time-warning-icon" class="start-time-warning-icon" style="display: none;">
                                    <span class="warning-tooltip">Для этого времени нет доступных периодов. Выберите другие параметры.</span>
                                    ⚠
                                </span>
                                <span class="chevron">
                                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                                        xmlns="http://www.w3.org/2000/svg">
                                        <path d="M6 9L12 15L18 9" stroke="#818EA2" stroke-width="2" />
                                    </svg>
                                </span>
                                <ul class="options">
                                    <li data-value="1">10:00</li>
                                    <li data-value="2">11:00</li>
                                    <li data-value="3">12:00</li>
                                    <li data-value="4">13:00</li>
                                    <li data-value="5">14:00</li>
                                </ul>
                            </div>
                        </div>

                        <!--Выпадающий список Время окончания-->
                        <div class="col-md-3">
                            <label for="end-time" class="form-label">Время окончания</label>
                            <div class="custom-select custom-select--clearable" id="end-time" name="end-time" data-placeholder="Выберите время">
                                <span class="selected">Выберите время</span>
                                <button type="button" class="custom-select-clear" aria-label="Сбросить выбор">×</button>
                                <span class="chevron">
                                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                                        xmlns="http://www.w3.org/2000/svg">
                                        <path d="M6 9L12 15L18 9" stroke="#818EA2" stroke-width="2" />
                                    </svg>
                                </span>
                                <ul class="options">
                                    <li data-value="1">11:00</li>
                                    <li data-value="2">12:00</li>
                                    <li data-value="3">13:00</li>
                                    <li data-value="4">14:00</li>
                                    <li data-value="5">15:00</li>
                                </ul>
                            </div>
                        </div>

                        <!--Выпадающий список Длительность-->
                        <div class="col-md-3">
                            <label for="duration" class="form-label">Длительность</label>
                            <div class="custom-select custom-select--clearable" id="duration" name="duration" data-placeholder="Выберите длительность">
                                <span class="selected">Выберите длительность</span>
                                <button type="button" class="custom-select-clear" aria-label="Сбросить выбор">×</button>
                                <span class="chevron">
                                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                                        xmlns="http://www.w3.org/2000/svg">
                                        <path d="M6 9L12 15L18 9" stroke="#818EA2" stroke-width="2" />
                                    </svg>
                                </span>
                                <ul class="options">
                                    <li data-value="1">2 часа</li>
                                    <li data-value="2">3 часа</li>
                                    <li data-value="3">4 часа</li>
                                    <li data-value="4">5 часов</li>
                                    <li data-value="5">6 часов</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <div class="row mb-3">
                        <!--Выпадающий список Преподаватель-->
                        <div class="col-md-6">
                            <label for="teacher" class="form-label">Преподаватель</label>
                            <div class="custom-select custom-select--clearable" id="teacher" name="teacher" data-placeholder="Выберите преподавателя">
                                <span class="selected">Выберите преподавателя</span>
                                <button type="button" class="custom-select-clear" aria-label="Сбросить выбор">×</button>
                                <span class="chevron">
                                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                                        xmlns="http://www.w3.org/2000/svg">
                                        <path d="M6 9L12 15L18 9" stroke="#818EA2" stroke-width="2" />
                                    </svg>
                                </span>
                                <ul class="options">
                                    {% for specialist in specialists %}
                                        {% if specialist.active %}
                                            <li data-value="{{ specialist.id }}" data-directions="{% for direction in specialist.directions.all %}{{ direction.id }}{% if not forloop.last %},{% endif %}{% endfor %}">{{ specialist.name }}</li>
                                        {% endif %}
                                    {% endfor %}
                                </ul>
                            </div>
                        </div>

                        <!--Выпадающий список со множественным выбором Услуги-->
                        <div class="col-md-6">
                            <label for="services" class="form-label">Услуги (необязательно)</label>
                            <div class="custom-select" id="services" name="services">
                                <span class="selected">Выберите услугу</span>
                                <span class="chevron">
                                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                                        xmlns="http://www.w3.org/2000/svg">
                                        <path d="M6 9L12 15L18 9" stroke="#818EA2" stroke-width="2" />
                                    </svg>
                                </span>
                                <ul class="options">
                                    {% for service in services %}
                                        {% if service.active %}
                                            <li data-value="{{ service.id }}" data-scenario-id="{{ service.scenario_id|default_if_none:'' }}" data-room-id="{{ service.room_id|default_if_none:'' }}">{{ service.name }}</li>
                                        {% endif %}
                                    {% endfor %}
                                </ul>
                            </div>
                        </div>
                    </div>

                    <!--Комментарий-->
                    <div class="row mb-3">
                        <div class="col-md-12">
                            <label for="bookingComment" class="form-label">Комментарий</label>
                            <textarea class="form-control" id="bookingComment" name="bookingComment" rows="3"
                                placeholder="Добавьте комментарий" maxlength="1000"></textarea>
                            <div class="char-counter" id="bookingCommentCounter">0/1000</div>
                        </div>
                    </div>

                    <!--Чекбокс пробное занятие-->
                    <div class="row mb-5">
                        <div class="col-md-12 trial-checkbox-row">
                            <input class="form-check-input" type="checkbox" id="trialLessonCheckbox" name="trialLesson">
                            <label class="form-check-label" for="trialLessonCheckbox" id="trialLessonLabel">
                                Пробное занятие
                            </label>
                        </div>
                    </div>

                    <!--Расчетная стоимость-->
                    <div class="row mb-4">
                        <div class="col-md-3">
                            <div class="d-flex align-items-end" style="height: 100%;">
                                <label for="bookingCostValue" class="form-label mb-0">Расчётная стоимость:</label>
                            </div>
                        </div>
                        <div class="col-md-3">
                            <div class="d-flex align-items-end justify-content-end" style="height: 100%;">
                                <span id="bookingCostValue">0 BYN</span>
                            </div>
                        </div>
                    </div>

                    <!--Кнопки Добавить и Отмена-->
                    <div class="row mb-3">
                        <div class="col-md-3">
                            <button type="button" class="button-primary" id="createBookingSubmitBtn">Добавить</button>
                        </div>
                        <div class="col-md-3">
                            <button type="button" class="button-sec" data-bs-dismiss="modal">Отмена</button>
                        </div>
                    </div>


                </form>
            </div>
        </div>
    </div>
</div>

<script>
    // JS модалки создания брони

    // Функция открытия модального окна: подставляет комнату и сценарий в шапку + базовые hidden-поля
    function openModal(date, time, roomName, roomId, cell) {
        // Комната
        var roomNameSpan = document.getElementById('roomName');
        if (roomNameSpan) {
            roomNameSpan.textContent = roomName;
        }

        // Сценарий: берём из глобального фильтра window.currentScenarioFilterId + window.SCENARIOS (из user_index.html)
        if (window.currentScenarioFilterId && Array.isArray(window.SCENARIOS)) {
            var scenarioId = String(window.currentScenarioFilterId);
            var scenarioObj = window.SCENARIOS.find(function (s) { return String(s.pk) === scenarioId; });
            var scenarioNameSpan = document.getElementById('scenarioName');
            if (scenarioNameSpan) {
                scenarioNameSpan.textContent = (scenarioObj && scenarioObj.fields && scenarioObj.fields.name)
                    ? scenarioObj.fields.name
                    : 'Название сценария';
            }
        }

        // Базовые скрытые поля (если нужны бэкенду)
        var dateField = document.getElementById('dateField');
        var timeField = document.getElementById('timeField');
        var roomNameField = document.getElementById('roomNameField');
        var roomIdField = document.getElementById('roomIdField');
        var fullDatetimeField = document.getElementById('fullDatetimeField');

        var fullDatetimeStr = (cell && typeof cell.getAttribute === 'function')
            ? (cell.getAttribute('full_datetime') || '')
            : '';

        if (dateField) dateField.value = date;
        if (timeField) timeField.value = time;
        if (roomNameField) roomNameField.value = roomName;
        if (roomIdField) roomIdField.value = roomId;

        if (fullDatetimeField) {
            fullDatetimeField.value = fullDatetimeStr;
        }

        // Видимые поля
        if (fullDatetimeStr) {
            var dtParts = fullDatetimeStr.split(' ');
            if (dtParts.length >= 2) {
                var dateIso = dtParts[0];
                var timeRaw = dtParts[1];
                var timeParts = String(timeRaw).split(':');
                var timeHm = timeParts.length >= 2 ? (timeParts[0] + ':' + timeParts[1]) : String(timeRaw);

                var modalDateInput = document.getElementById('modal-create-date');
                if (modalDateInput) {
                    modalDateInput.value = dateIso;
                }

                // =====================================================
                // МОДУЛЬ УПРАВЛЕНИЯ ВРЕМЕНЕМ БРОНИ
                // =====================================================
                // 
                // Управляет тремя связанными селектами:
                // - Время начала (start-time)
                // - Длительность (duration) — в периодах по minMinutes минут
                // - Время окончания (end-time)
                //
                // ЛОГИКА ВЗАИМОДЕЙСТВИЯ:
                // 1. При выборе времени начала:
                //    - Список окончаний формируется "вправо" от начала
                //    - Если есть окончание — вычисляется длительность
                //
                // 2. При выборе времени окончания:
                //    - Список начала формируется "влево" от окончания
                //    - Если есть начало — вычисляется длительность
                //
                // 3. При выборе длительности:
                //    - Списки начала/окончания фильтруются по длительности
                //    - Если есть начало — подставляется окончание
                //    - Если есть окончание — подставляется начало
                //
                // 4. Кнопка "Добавить" активна только когда выбраны
                //    и время начала, и время окончания
                // =====================================================

                // --- Вспомогательные функции: получение данных сценария ---

                // Получить минимальную длительность периода из текущего сценария (в минутах)
                function getScenarioMinDurationMinutes() {
                    var fallback = 60;
                    if (!window.currentScenarioFilterId || !Array.isArray(window.SCENARIOS)) {
                        return fallback;
                    }
                    var scenarioId = String(window.currentScenarioFilterId);
                    var scenarioObj = window.SCENARIOS.find(function (s) { return String(s.pk) === scenarioId; });
                    var raw = scenarioObj && scenarioObj.fields ? scenarioObj.fields.min_booking_duration_minutes : null;
                    var val = parseInt(raw, 10);
                    return (!isNaN(val) && val > 0) ? val : fallback;
                }

                // Получить work_time_start сценария в минутах от полуночи
                function getScenarioWorkTimeStartMinutes() {
                    if (!window.currentScenarioFilterId || !Array.isArray(window.SCENARIOS)) {
                        return 0;
                    }
                    var scenarioId = String(window.currentScenarioFilterId);
                    var scenarioObj = window.SCENARIOS.find(function (s) { return String(s.pk) === scenarioId; });
                    if (!scenarioObj || !scenarioObj.fields || !scenarioObj.fields.work_time_start) {
                        return 0;
                    }
                    var parts = String(scenarioObj.fields.work_time_start).split(':');
                    if (parts.length < 2) return 0;
                    var h = parseInt(parts[0], 10);
                    var m = parseInt(parts[1], 10);
                    if (isNaN(h) || isNaN(m)) return 0;
                    return h * 60 + m;
                }

                // Получить work_time_end сценария в минутах от полуночи
                function getScenarioWorkTimeEndMinutes() {
                    if (!window.currentScenarioFilterId || !Array.isArray(window.SCENARIOS)) {
                        return 24 * 60;
                    }
                    var scenarioId = String(window.currentScenarioFilterId);
                    var scenarioObj = window.SCENARIOS.find(function (s) { return String(s.pk) === scenarioId; });
                    if (!scenarioObj || !scenarioObj.fields || !scenarioObj.fields.work_time_end) {
                        return 24 * 60;
                    }
                    var parts = String(scenarioObj.fields.work_time_end).split(':');
                    if (parts.length < 2) return 24 * 60;
                    var h = parseInt(parts[0], 10);
                    var m = parseInt(parts[1], 10);
                    if (isNaN(h) || isNaN(m)) return 24 * 60;
                    return h * 60 + m;
                }

                // Преобразовать datetime строку "YYYY-MM-DD HH:MM:SS" в объект Date
                function parseDatetimeStr(dtStr) {
                    if (!dtStr) return null;
                    var parts = dtStr.split(' ');
                    if (parts.length < 2) return null;
                    var dateParts = parts[0].split('-');
                    var timeParts = parts[1].split(':');
                    if (dateParts.length < 3 || timeParts.length < 2) return null;
                    return new Date(
                        parseInt(dateParts[0], 10),
                        parseInt(dateParts[1], 10) - 1,
                        parseInt(dateParts[2], 10),
                        parseInt(timeParts[0], 10),
                        parseInt(timeParts[1], 10),
                        timeParts[2] ? parseInt(timeParts[2], 10) : 0
                    );
                }

                // Форматирование времени из минут от полуночи в HH:MM
                function formatTimeHHMM(totalMinutes) {
                    var m = parseInt(totalMinutes, 10);
                    if (isNaN(m) || m < 0) return '';
                    var h = Math.floor(m / 60) % 24;
                    var mm = m % 60;
                    return String(h).padStart(2, '0') + ':' + String(mm).padStart(2, '0');
                }

                // Парсинг времени HH:MM в минуты от полуночи
                function parseTimeToMinutes(timeStr) {
                    if (!timeStr) return 0;
                    var parts = String(timeStr).split(':');
                    if (parts.length < 2) return 0;
                    return parseInt(parts[0], 10) * 60 + parseInt(parts[1], 10);
                }

                // Форматирование длительности для отображения
                function formatDurationHuman(totalMinutes) {
                    var m = parseInt(totalMinutes, 10);
                    if (isNaN(m) || m <= 0) return '';
                    var h = Math.floor(m / 60);
                    var mm = m % 60;
                    if (h > 0 && mm > 0) return h + ' ч ' + mm + ' мин';
                    if (h > 0) return h + ' ч';
                    return mm + ' мин';
                }

                // Форматирование длительности в HH:MM для отправки на сервер
                function formatDurationHHMM(totalMinutes) {
                    var m = parseInt(totalMinutes, 10);
                    if (isNaN(m) || m < 0) return '';
                    var h = Math.floor(m / 60);
                    var mm = m % 60;
                    return String(h).padStart(2, '0') + ':' + String(mm).padStart(2, '0');
                }

                // Склонение слова "период"
                function formatPeriodsLabel(n) {
                    var k = parseInt(n, 10);
                    if (k === 1) return 'период';
                    if (k >= 2 && k <= 4) return 'периода';
                    return 'периодов';
                }

                // Получить все брони в комнате на выбранную дату
                function getRoomBookingsForDate(currentRoomId, dateIso) {
                    var bookings = window.bookingsInRange || (typeof bookingsInRange !== 'undefined' ? bookingsInRange : []);
                    if (!Array.isArray(bookings)) return [];
                    
                    var result = [];
                    bookings.forEach(function (booking) {
                        if (String(booking.idroom) !== String(currentRoomId)) return;
                        if (!booking.blocks_datetime_range || !booking.blocks_datetime_range.length) return;
                        
                        // Проверяем, что бронь на нужную дату
                        var firstBlock = booking.blocks_datetime_range[0];
                        if (!firstBlock || !firstBlock.startsWith(dateIso)) return;
                        
                        var startDt = parseDatetimeStr(booking.blocks_datetime_range[0]);
                        var endDt = parseDatetimeStr(booking.blocks_datetime_range[booking.blocks_datetime_range.length - 1]);
                        if (!startDt || !endDt) return;
                        
                        // blocks_datetime_range содержит времена до datetimeend включительно
                        // Последний элемент — это время окончания брони
                        var startMinutes = startDt.getHours() * 60 + startDt.getMinutes();
                        var endMinutes = endDt.getHours() * 60 + endDt.getMinutes();
                        
                        result.push({
                            startMinutes: startMinutes,
                            endMinutes: endMinutes
                        });
                    });
                    return result;
                }

                // Вычислить доступные слоты времени начала для комнаты на дату
                // Шаг = 15 минут (шаг сетки календаря), слот доступен если есть minMinutes до брони/конца дня
                function getAvailableStartTimeSlots(currentRoomId, dateIso) {
                    var minMinutes = getScenarioMinDurationMinutes();
                    var workStart = getScenarioWorkTimeStartMinutes();
                    var workEnd = getScenarioWorkTimeEndMinutes();
                    var roomBookings = getRoomBookingsForDate(currentRoomId, dateIso);
                    var gridStep = 15; // Шаг сетки календаря в минутах
                    
                    var slots = [];
                    
                    // Сортируем брони по времени начала
                    roomBookings.sort(function (a, b) { return a.startMinutes - b.startMinutes; });
                    
                    // Перебираем все временные слоты с шагом 15 минут
                    for (var currentTime = workStart; currentTime + minMinutes <= workEnd; currentTime += gridStep) {
                        var isBlocked = false;
                        
                        // Проверяем, не попадает ли слот внутрь существующей брони
                        for (var i = 0; i < roomBookings.length; i++) {
                            var booking = roomBookings[i];
                            
                            // Слот блокирован, если он начинается во время брони
                            if (currentTime >= booking.startMinutes && currentTime < booking.endMinutes) {
                                isBlocked = true;
                                break;
                            }
                            
                            // Слот блокирован, если минимальная бронь не помещается до начала следующей брони
                            if (currentTime < booking.startMinutes && currentTime + minMinutes > booking.startMinutes) {
                                isBlocked = true;
                                break;
                            }
                        }
                        
                        if (!isBlocked) {
                            slots.push(currentTime);
                        }
                    }
                    
                    return slots;
                }

                // Вычислить максимальное количество периодов для заданного времени начала
                function getMaxPeriodsForStartTime(startTimeMinutes, currentRoomId, dateIso) {
                    var minMinutes = getScenarioMinDurationMinutes();
                    var workEnd = getScenarioWorkTimeEndMinutes();
                    var roomBookings = getRoomBookingsForDate(currentRoomId, dateIso);
                    
                    // Ограничение 1: до конца рабочего времени
                    var minutesToWorkEnd = workEnd - startTimeMinutes;
                    if (minutesToWorkEnd <= 0) return 0;
                    
                    // Ограничение 2: до следующей брони
                    var minutesToNextBooking = null;
                    roomBookings.forEach(function (booking) {
                        if (booking.startMinutes > startTimeMinutes) {
                            var diff = booking.startMinutes - startTimeMinutes;
                            if (minutesToNextBooking === null || diff < minutesToNextBooking) {
                                minutesToNextBooking = diff;
                            }
                        }
                    });
                    
                    // Итоговое ограничение
                    var availableMinutes = minutesToWorkEnd;
                    if (minutesToNextBooking !== null) {
                        availableMinutes = Math.min(availableMinutes, minutesToNextBooking);
                    }
                    
                    return Math.floor(availableMinutes / minMinutes);
                }

                // --- Состояние модуля ---
                // Длительность — главный показатель. Списки начала/конца формируются по ней.
                var currentRoomId = roomIdField ? roomIdField.value : roomId;
                var minMinutes = getScenarioMinDurationMinutes();
                var clickedSlotMinutes = parseTimeToMinutes(timeHm);
                
                // Текущие выбранные значения (null = не выбрано, показывается placeholder)
                var currentStartTimeMinutes = null;
                var currentSelectedPeriods = 1;
                var currentEndTimeMinutes = null;

                // --- DOM элементы ---
                var startTimeSelect = document.getElementById('start-time');
                var durationSelect = document.getElementById('duration');
                var endTimeSelect = document.getElementById('end-time');
                var submitBtn = document.getElementById('createBookingSubmitBtn');

                // --- Функции формирования списков времени ---

                // Получить слоты времени начала, с которых доступно >= requiredPeriods периодов
                function getStartTimeSlotsForPeriods(requiredPeriods) {
                    var allSlots = getAvailableStartTimeSlots(currentRoomId, dateIso);
                    if (requiredPeriods <= 1) return allSlots;
                    
                    return allSlots.filter(function (slotMinutes) {
                        var maxPeriods = getMaxPeriodsForStartTime(slotMinutes, currentRoomId, dateIso);
                        return maxPeriods >= requiredPeriods;
                    });
                }

                // Получить все возможные времена окончания для заданного кол-ва периодов (глобально)
                function getAllEndTimesForPeriods(requiredPeriods) {
                    var slots = getStartTimeSlotsForPeriods(requiredPeriods);
                    var endTimes = [];
                    var duration = minMinutes * requiredPeriods;
                    
                    slots.forEach(function (startMinutes) {
                        var endMinutes = startMinutes + duration;
                        if (endTimes.indexOf(endMinutes) === -1) {
                            endTimes.push(endMinutes);
                        }
                    });
                    
                    endTimes.sort(function (a, b) { return a - b; });
                    return endTimes;
                }

                // Получить времена окончания "вправо" от заданного времени начала (для конкретного слота)
                function getEndTimesForStartTime(startTimeMinutes) {
                    var maxPeriods = getMaxPeriodsForStartTime(startTimeMinutes, currentRoomId, dateIso);
                    var endTimes = [];
                    
                    for (var p = 1; p <= maxPeriods; p++) {
                        var endMinutes = startTimeMinutes + (minMinutes * p);
                        endTimes.push(endMinutes);
                    }
                    
                    return endTimes;
                }

                // Получить времена начала "влево" от заданного времени окончания (для конкретного слота)
                function getStartTimesForEndTime(endTimeMinutes) {
                    var allSlots = getStartTimeSlotsForPeriods(1);
                    var startTimes = [];
                    
                    allSlots.forEach(function (slotMinutes) {
                        if (slotMinutes < endTimeMinutes) {
                            var maxPeriods = getMaxPeriodsForStartTime(slotMinutes, currentRoomId, dateIso);
                            var maxEndTime = slotMinutes + (minMinutes * maxPeriods);
                            // Проверяем, что с этого слота можно дойти до нужного времени окончания
                            if (maxEndTime >= endTimeMinutes) {
                                startTimes.push(slotMinutes);
                            }
                        }
                    });
                    
                    startTimes.sort(function (a, b) { return a - b; });
                    return startTimes;
                }

                // --- Вычислить глобальное максимальное количество периодов ---
                function getGlobalMaxPeriods() {
                    var allSlots = getStartTimeSlotsForPeriods(1);
                    var maxPeriods = 0;
                    allSlots.forEach(function (slotMinutes) {
                        var mp = getMaxPeriodsForStartTime(slotMinutes, currentRoomId, dateIso);
                        if (mp > maxPeriods) maxPeriods = mp;
                    });
                    return maxPeriods;
                }

                // --- Вычислить максимальное количество периодов для времени окончания ---
                function getMaxPeriodsForEndTime(endTimeMinutes) {
                    var startTimesForEnd = getStartTimesForEndTime(endTimeMinutes);
                    var maxPeriods = 0;
                    for (var p = 1; p <= 20; p++) {
                        var potentialStart = endTimeMinutes - (minMinutes * p);
                        if (startTimesForEnd.indexOf(potentialStart) !== -1) {
                            maxPeriods = p;
                        }
                    }
                    return maxPeriods;
                }

                // --- Функции управления UI ---

                // Активирует/деактивирует кнопку "Добавить" в зависимости от заполненности времени
                function updateSubmitButtonState() {
                    if (!submitBtn) return;
                    var hasStartTime = currentStartTimeMinutes !== null;
                    var hasEndTime = currentEndTimeMinutes !== null;
                    submitBtn.disabled = !(hasStartTime && hasEndTime);
                }

                // Управляет отображением крестика сброса для селекта (класс has-selection)
                function updateSelectHasSelection(selectEl, hasValue) {
                    if (!selectEl) return;
                    if (hasValue) {
                        selectEl.classList.add('has-selection');
                    } else {
                        selectEl.classList.remove('has-selection');
                    }
                }

                // --- Функции перестроения селектов ---

                // Перестраивает селект "Длительность" с заданным количеством периодов
                // selectedPeriods = null — показывает плейсхолдер "выберите период"
                function rebuildDurationSelect(selectedPeriods, maxPeriods) {
                    if (!durationSelect) return;
                    
                    var durationSelectedSpan = durationSelect.querySelector('.selected');
                    var durationOptionsUl = durationSelect.querySelector('ul.options');
                    var placeholder = durationSelect.getAttribute('data-placeholder') || 'Выберите период';
                    
                    if (durationOptionsUl) {
                        durationOptionsUl.innerHTML = '';
                    }
                    
                    if (maxPeriods <= 0) {
                        if (durationSelectedSpan) {
                            durationSelectedSpan.textContent = 'Нет доступных периодов';
                        }
                        durationSelect.classList.add('disabled');
                        updateSelectHasSelection(durationSelect, false);
                        return;
                    }
                    
                    durationSelect.classList.remove('disabled');
                    
                    // Если период не выбран — показываем плейсхолдер
                    if (selectedPeriods === null) {
                        if (durationSelectedSpan) {
                            durationSelectedSpan.textContent = placeholder;
                        }
                    }
                    
                    for (var i = 1; i <= maxPeriods; i++) {
                        var total = minMinutes * i;
                        var human = formatDurationHuman(total);
                        var value = formatDurationHHMM(total);
                        var label = i + ' ' + formatPeriodsLabel(i) + ' — ' + human;
                        
                        var li = document.createElement('li');
                        li.textContent = label;
                        li.setAttribute('data-value', value);
                        li.setAttribute('data-periods', i);
                        
                        if (i === selectedPeriods) {
                            li.classList.add('selected');
                            if (durationSelectedSpan) {
                                durationSelectedSpan.textContent = label;
                            }
                        }
                        
                        // Обработчик: при выборе длительности → обновить списки начала/конца
                        (function (liEl, liLabel, periods) {
                            liEl.addEventListener('click', function (e) {
                                e.stopPropagation();
                                durationOptionsUl.querySelectorAll('li').forEach(function (opt) {
                                    opt.classList.remove('selected');
                                });
                                liEl.classList.add('selected');
                                if (durationSelectedSpan) {
                                    durationSelectedSpan.textContent = liLabel;
                                }
                                durationSelect.classList.remove('open');
                                
                                currentSelectedPeriods = periods;
                                // Крестик сброса показываем только при >1 периоде
                                updateSelectHasSelection(durationSelect, periods > 1);
                                onDurationChanged();
                            });
                        })(li, label, i);
                        
                        durationOptionsUl.appendChild(li);
                    }
                    
                    // Крестик сброса показываем только при выбранном периоде >1
                    updateSelectHasSelection(durationSelect, selectedPeriods !== null && selectedPeriods > 1);
                }

                // Перестраивает селект "Время начала" с заданным списком слотов
                function rebuildStartTimeSelect(slotsMinutes, selectedMinutes) {
                    if (!startTimeSelect) return;
                    
                    var startSelectedSpan = startTimeSelect.querySelector('.selected');
                    var startOptionsUl = startTimeSelect.querySelector('ul.options');
                    
                    if (startOptionsUl) {
                        startOptionsUl.innerHTML = '';
                    }
                    
                    var placeholder = startTimeSelect.getAttribute('data-placeholder') || 'Выберите время';
                    
                    if (slotsMinutes.length === 0) {
                        if (startSelectedSpan) {
                            startSelectedSpan.textContent = placeholder;
                        }
                        startTimeSelect.classList.add('disabled');
                        updateSelectHasSelection(startTimeSelect, false);
                        return;
                    }
                    
                    startTimeSelect.classList.remove('disabled');
                    
                    // hasSelection = время есть в списке доступных, hasValue = время установлено (может быть номинальным)
                    var hasSelection = selectedMinutes !== null && slotsMinutes.indexOf(selectedMinutes) !== -1;
                    var hasValue = selectedMinutes !== null;
                    
                    if (startSelectedSpan) {
                        // Показываем время даже если его нет в списке (номинальное отображение)
                        startSelectedSpan.textContent = hasValue ? formatTimeHHMM(selectedMinutes) : placeholder;
                    }
                    
                    slotsMinutes.forEach(function (slotMinutes) {
                        var slotTimeStr = formatTimeHHMM(slotMinutes);
                        var li = document.createElement('li');
                        li.textContent = slotTimeStr;
                        li.setAttribute('data-value', slotTimeStr);
                        li.setAttribute('data-minutes', slotMinutes);
                        
                        if (slotMinutes === selectedMinutes) {
                            li.classList.add('selected');
                        }
                        
                        // Обработчик: при выборе времени начала → подставить время конца
                        (function (liEl, liTimeStr, liMinutes) {
                            liEl.addEventListener('click', function (e) {
                                e.stopPropagation();
                                startOptionsUl.querySelectorAll('li').forEach(function (opt) {
                                    opt.classList.remove('selected');
                                });
                                liEl.classList.add('selected');
                                if (startSelectedSpan) {
                                    startSelectedSpan.textContent = liTimeStr;
                                }
                                startTimeSelect.classList.remove('open');
                                updateSelectHasSelection(startTimeSelect, true);
                                
                                currentStartTimeMinutes = liMinutes;
                                if (timeField) timeField.value = liTimeStr;
                                
                                // Скрываем предупреждение о недоступном слоте (выбрано доступное время)
                                var startTimeWarning = document.getElementById('start-time-warning-icon');
                                if (startTimeWarning) startTimeWarning.style.display = 'none';
                                
                                // Пересчитываем список длительностей для этого времени начала
                                var maxPeriodsForStart = getMaxPeriodsForStartTime(liMinutes, currentRoomId, dateIso);
                                
                                // Обновляем список окончаний "вправо" от времени начала
                                var endTimesForStart = getEndTimesForStartTime(liMinutes);
                                
                                if (currentEndTimeMinutes !== null) {
                                    // Есть время окончания — вычисляем и подставляем длительность
                                    var periodsBetween = Math.round((currentEndTimeMinutes - liMinutes) / minMinutes);
                                    if (periodsBetween >= 1 && periodsBetween <= maxPeriodsForStart && endTimesForStart.indexOf(currentEndTimeMinutes) !== -1) {
                                        // Время окончания валидно для нового начала
                                        currentSelectedPeriods = periodsBetween;
                                        rebuildDurationSelect(currentSelectedPeriods, maxPeriodsForStart);
                                    } else {
                                        // Время окончания не валидно — сбрасываем его
                                        currentEndTimeMinutes = null;
                                        currentSelectedPeriods = null;
                                        rebuildDurationSelect(null, maxPeriodsForStart);
                                    }
                                } else if (currentSelectedPeriods !== null) {
                                    // Период выбран, но нет окончания — подставляем окончание
                                    if (currentSelectedPeriods > maxPeriodsForStart) {
                                        currentSelectedPeriods = maxPeriodsForStart > 0 ? 1 : 0;
                                    }
                                    currentEndTimeMinutes = liMinutes + (minMinutes * currentSelectedPeriods);
                                    rebuildDurationSelect(currentSelectedPeriods, maxPeriodsForStart);
                                } else {
                                    // Ничего не выбрано — показываем плейсхолдер
                                    rebuildDurationSelect(null, maxPeriodsForStart);
                                }
                                
                                rebuildEndTimeSelect(endTimesForStart, currentEndTimeMinutes);
                                updateSubmitButtonState();
                            });
                        })(li, slotTimeStr, slotMinutes);
                        
                        startOptionsUl.appendChild(li);
                    });
                    
                    updateSelectHasSelection(startTimeSelect, hasSelection);
                }

                // Перестраивает селект "Время окончания" с заданным списком времен
                function rebuildEndTimeSelect(endTimesMinutes, selectedMinutes) {
                    if (!endTimeSelect) return;
                    
                    var endTimeSelectedSpan = endTimeSelect.querySelector('.selected');
                    var endTimeOptionsUl = endTimeSelect.querySelector('ul.options');
                    
                    if (endTimeOptionsUl) {
                        endTimeOptionsUl.innerHTML = '';
                    }
                    
                    var placeholder = endTimeSelect.getAttribute('data-placeholder') || 'Выберите время';
                    
                    if (endTimesMinutes.length === 0) {
                        if (endTimeSelectedSpan) {
                            endTimeSelectedSpan.textContent = placeholder;
                        }
                        endTimeSelect.classList.add('disabled');
                        updateSelectHasSelection(endTimeSelect, false);
                        return;
                    }
                    
                    endTimeSelect.classList.remove('disabled');
                    
                    var hasSelection = selectedMinutes !== null && endTimesMinutes.indexOf(selectedMinutes) !== -1;
                    
                    if (endTimeSelectedSpan) {
                        endTimeSelectedSpan.textContent = hasSelection ? formatTimeHHMM(selectedMinutes) : placeholder;
                    }
                    
                    endTimesMinutes.forEach(function (endMinutes) {
                        var endTimeStr = formatTimeHHMM(endMinutes);
                        var li = document.createElement('li');
                        li.textContent = endTimeStr;
                        li.setAttribute('data-value', endTimeStr);
                        li.setAttribute('data-minutes', endMinutes);
                        
                        if (endMinutes === selectedMinutes) {
                            li.classList.add('selected');
                        }
                        
                        // Обработчик: при выборе времени окончания → подставить время начала
                        (function (liEl, liTimeStr, liMinutes) {
                            liEl.addEventListener('click', function (e) {
                                e.stopPropagation();
                                endTimeOptionsUl.querySelectorAll('li').forEach(function (opt) {
                                    opt.classList.remove('selected');
                                });
                                liEl.classList.add('selected');
                                if (endTimeSelectedSpan) {
                                    endTimeSelectedSpan.textContent = liTimeStr;
                                }
                                endTimeSelect.classList.remove('open');
                                updateSelectHasSelection(endTimeSelect, true);
                                
                                currentEndTimeMinutes = liMinutes;
                                
                                // Обновляем список начала "влево" от времени окончания
                                var startTimesForEnd = getStartTimesForEndTime(liMinutes);
                                var maxPeriodsForEnd = getMaxPeriodsForEndTime(liMinutes);
                                
                                if (currentStartTimeMinutes !== null) {
                                    // Есть время начала — вычисляем и подставляем длительность
                                    var periodsBetween = Math.round((liMinutes - currentStartTimeMinutes) / minMinutes);
                                    if (periodsBetween >= 1 && periodsBetween <= maxPeriodsForEnd && startTimesForEnd.indexOf(currentStartTimeMinutes) !== -1) {
                                        // Время начала валидно для нового окончания
                                        currentSelectedPeriods = periodsBetween;
                                        rebuildDurationSelect(currentSelectedPeriods, maxPeriodsForEnd);
                                        
                                        // Скрываем предупреждение о недоступном слоте
                                        var startTimeWarning = document.getElementById('start-time-warning-icon');
                                        if (startTimeWarning) startTimeWarning.style.display = 'none';
                                    } else {
                                        // Время начала не валидно — сбрасываем его
                                        currentStartTimeMinutes = null;
                                        currentSelectedPeriods = null;
                                        rebuildDurationSelect(null, maxPeriodsForEnd);
                                    }
                                } else if (currentSelectedPeriods !== null) {
                                    // Период выбран, но нет начала — подставляем начало
                                    var potentialStart = liMinutes - (minMinutes * currentSelectedPeriods);
                                    if (startTimesForEnd.indexOf(potentialStart) !== -1) {
                                        currentStartTimeMinutes = potentialStart;
                                        if (timeField) timeField.value = formatTimeHHMM(currentStartTimeMinutes);
                                        rebuildDurationSelect(currentSelectedPeriods, maxPeriodsForEnd);
                                    } else {
                                        // Не удалось подставить — сбрасываем период
                                        currentSelectedPeriods = null;
                                        rebuildDurationSelect(null, maxPeriodsForEnd);
                                    }
                                } else {
                                    // Ничего не выбрано — показываем плейсхолдер
                                    rebuildDurationSelect(null, maxPeriodsForEnd);
                                }
                                
                                rebuildStartTimeSelect(startTimesForEnd, currentStartTimeMinutes);
                                updateSubmitButtonState();
                            });
                        })(li, endTimeStr, endMinutes);
                        
                        endTimeOptionsUl.appendChild(li);
                    });
                    
                    updateSelectHasSelection(endTimeSelect, hasSelection);
                }

                // --- Синхронизировать отображение времени начала с текущим значением ---
                function syncStartTimeDisplay() {
                    if (!startTimeSelect) return;
                    var startSelectedSpan = startTimeSelect.querySelector('.selected');
                    var startOptionsUl = startTimeSelect.querySelector('ul.options');
                    
                    if (currentStartTimeMinutes === null) {
                        if (startSelectedSpan) {
                            startSelectedSpan.textContent = startTimeSelect.getAttribute('data-placeholder') || 'Выберите время';
                        }
                        updateSelectHasSelection(startTimeSelect, false);
                    } else {
                        if (startSelectedSpan) {
                            startSelectedSpan.textContent = formatTimeHHMM(currentStartTimeMinutes);
                        }
                        updateSelectHasSelection(startTimeSelect, true);
                    }
                    
                    if (startOptionsUl) {
                        startOptionsUl.querySelectorAll('li').forEach(function (li) {
                            var mins = parseInt(li.getAttribute('data-minutes'), 10);
                            if (mins === currentStartTimeMinutes) {
                                li.classList.add('selected');
                            } else {
                                li.classList.remove('selected');
                            }
                        });
                    }
                }

                // --- Обработчики событий изменения селектов ---

                // Обработчик изменения длительности: обновляет списки начала/окончания
                function onDurationChanged() {
                    var durationMinutes = minMinutes * currentSelectedPeriods;
                    
                    // Списки начала/окончания фильтруются по выбранной длительности
                    var filteredStartSlots = getStartTimeSlotsForPeriods(currentSelectedPeriods);
                    var filteredEndTimes = getAllEndTimesForPeriods(currentSelectedPeriods);
                    
                    if (currentStartTimeMinutes !== null) {
                        // Есть время начала — подставляем окончание
                        var maxPeriodsForStart = getMaxPeriodsForStartTime(currentStartTimeMinutes, currentRoomId, dateIso);
                        if (currentSelectedPeriods <= maxPeriodsForStart) {
                            currentEndTimeMinutes = currentStartTimeMinutes + durationMinutes;
                        } else {
                            // Период недоступен для этого начала — сбрасываем оба
                            currentStartTimeMinutes = null;
                            currentEndTimeMinutes = null;
                            // Скрываем значок предупреждения (номинальное время сброшено)
                            var startTimeWarning = document.getElementById('start-time-warning-icon');
                            if (startTimeWarning) startTimeWarning.style.display = 'none';
                        }
                        
                        rebuildStartTimeSelect(filteredStartSlots, currentStartTimeMinutes);
                        rebuildEndTimeSelect(filteredEndTimes, currentEndTimeMinutes);
                    } else if (currentEndTimeMinutes !== null) {
                        // Есть время окончания — подставляем начало
                        var potentialStart = currentEndTimeMinutes - durationMinutes;
                        
                        if (filteredStartSlots.indexOf(potentialStart) !== -1) {
                            currentStartTimeMinutes = potentialStart;
                            if (timeField) timeField.value = formatTimeHHMM(currentStartTimeMinutes);
                        } else {
                            // Время начала для этой длительности недоступно — сбрасываем время окончания
                            currentEndTimeMinutes = null;
                        }
                        
                        rebuildStartTimeSelect(filteredStartSlots, currentStartTimeMinutes);
                        rebuildEndTimeSelect(filteredEndTimes, currentEndTimeMinutes);
                    } else {
                        // Ничего не выбрано — списки фильтруются по длительности
                        rebuildStartTimeSelect(filteredStartSlots, null);
                        rebuildEndTimeSelect(filteredEndTimes, null);
                    }
                    
                    updateSubmitButtonState();
                }

                // --- Функции сброса селектов (по нажатию крестика) ---

                // Сброс селекта "Время начала": сохраняет время окончания если есть
                function resetStartTime() {
                    currentStartTimeMinutes = null;
                    // НЕ сбрасываем время окончания
                    
                    // Скрываем предупреждение о недоступном слоте
                    var startTimeWarning = document.getElementById('start-time-warning-icon');
                    if (startTimeWarning) startTimeWarning.style.display = 'none';
                    
                    if (currentEndTimeMinutes !== null) {
                        // Есть время окончания — список начала "влево", сбрасываем длительность
                        var startTimesForEnd = getStartTimesForEndTime(currentEndTimeMinutes);
                        var maxPeriodsForEnd = getMaxPeriodsForEndTime(currentEndTimeMinutes);
                        currentSelectedPeriods = null;
                        rebuildDurationSelect(null, maxPeriodsForEnd);
                        rebuildStartTimeSelect(startTimesForEnd, null);
                        rebuildEndTimeSelect(getAllEndTimesForPeriods(1), currentEndTimeMinutes);
                    } else {
                        // Оба значения сброшены — глобальные списки
                        currentSelectedPeriods = null;
                        rebuildDurationSelect(null, getGlobalMaxPeriods());
                        rebuildStartTimeSelect(getStartTimeSlotsForPeriods(1), null);
                        rebuildEndTimeSelect(getAllEndTimesForPeriods(1), null);
                    }
                    
                    updateSubmitButtonState();
                }

                // Сброс селекта "Время окончания": сохраняет время начала если есть
                function resetEndTime() {
                    currentEndTimeMinutes = null;
                    // НЕ сбрасываем время начала
                    
                    if (currentStartTimeMinutes !== null) {
                        // Есть время начала — список окончаний "вправо", сбрасываем длительность
                        var maxPeriodsForStart = getMaxPeriodsForStartTime(currentStartTimeMinutes, currentRoomId, dateIso);
                        var endTimesForStart = getEndTimesForStartTime(currentStartTimeMinutes);
                        currentSelectedPeriods = null;
                        rebuildDurationSelect(null, maxPeriodsForStart);
                        rebuildStartTimeSelect(getStartTimeSlotsForPeriods(1), currentStartTimeMinutes);
                        rebuildEndTimeSelect(endTimesForStart, null);
                    } else {
                        // Оба значения сброшены — глобальные списки
                        currentSelectedPeriods = null;
                        rebuildDurationSelect(null, getGlobalMaxPeriods());
                        rebuildStartTimeSelect(getStartTimeSlotsForPeriods(1), null);
                        rebuildEndTimeSelect(getAllEndTimesForPeriods(1), null);
                    }
                    
                    updateSubmitButtonState();
                }

                // Сброс селекта "Длительность": сбрасывает связанные значения
                function resetDuration() {
                    // Сбрасываем на плейсхолдер "выберите период"
                    currentSelectedPeriods = null;
                    
                    if (currentStartTimeMinutes !== null) {
                        // Есть время начала — список окончаний "вправо", сбрасываем окончание
                        var maxPeriodsForStart = getMaxPeriodsForStartTime(currentStartTimeMinutes, currentRoomId, dateIso);
                        var endTimesForStart = getEndTimesForStartTime(currentStartTimeMinutes);
                        currentEndTimeMinutes = null;
                        rebuildDurationSelect(null, maxPeriodsForStart);
                        rebuildStartTimeSelect(getStartTimeSlotsForPeriods(1), currentStartTimeMinutes);
                        rebuildEndTimeSelect(endTimesForStart, null);
                    } else if (currentEndTimeMinutes !== null) {
                        // Есть время окончания — список начала "влево", сбрасываем начало
                        var startTimesForEnd = getStartTimesForEndTime(currentEndTimeMinutes);
                        var maxPeriodsForEnd = getMaxPeriodsForEndTime(currentEndTimeMinutes);
                        currentStartTimeMinutes = null;
                        rebuildDurationSelect(null, maxPeriodsForEnd);
                        rebuildStartTimeSelect(startTimesForEnd, null);
                        rebuildEndTimeSelect(getAllEndTimesForPeriods(1), currentEndTimeMinutes);
                    } else {
                        // Оба значения не установлены — глобальные списки
                        rebuildDurationSelect(null, getGlobalMaxPeriods());
                        rebuildStartTimeSelect(getStartTimeSlotsForPeriods(1), null);
                        rebuildEndTimeSelect(getAllEndTimesForPeriods(1), null);
                    }
                    
                    updateSubmitButtonState();
                }

                // --- Привязка обработчиков сброса (крестиков) ---
                function bindClearButtons() {
                    var startClearBtn = startTimeSelect ? startTimeSelect.querySelector('.custom-select-clear') : null;
                    var endClearBtn = endTimeSelect ? endTimeSelect.querySelector('.custom-select-clear') : null;
                    var durationClearBtn = durationSelect ? durationSelect.querySelector('.custom-select-clear') : null;
                    
                    if (startClearBtn) {
                        startClearBtn.addEventListener('click', function (e) {
                            e.preventDefault();
                            e.stopPropagation();
                            resetStartTime();
                            startTimeSelect.classList.remove('open');
                        });
                    }
                    
                    if (endClearBtn) {
                        endClearBtn.addEventListener('click', function (e) {
                            e.preventDefault();
                            e.stopPropagation();
                            resetEndTime();
                            endTimeSelect.classList.remove('open');
                        });
                    }
                    
                    if (durationClearBtn) {
                        durationClearBtn.addEventListener('click', function (e) {
                            e.preventDefault();
                            e.stopPropagation();
                            resetDuration();
                            durationSelect.classList.remove('open');
                        });
                    }
                }

                // --- Первоначальная инициализация ---
                bindClearButtons();
                
                // Вычисляем максимально возможное количество периодов
                var allStartSlots = getStartTimeSlotsForPeriods(1);
                var globalMaxPeriods = getGlobalMaxPeriods();
                
                // Проверяем доступность нажатого слота
                var clickedSlotMaxPeriods = getMaxPeriodsForStartTime(clickedSlotMinutes, currentRoomId, dateIso);
                var clickedSlotAvailable = clickedSlotMaxPeriods >= 1;
                
                // Элемент предупреждения о недоступном слоте
                var startTimeWarning = document.getElementById('start-time-warning-icon');
                
                // Начальное состояние: время начала установлено, время окончания и период НЕ выбраны
                currentSelectedPeriods = null;
                currentEndTimeMinutes = null;
                
                if (clickedSlotAvailable) {
                    // Слот доступен — устанавливаем только время начала
                    currentStartTimeMinutes = clickedSlotMinutes;
                    if (startTimeWarning) startTimeWarning.style.display = 'none';
                } else {
                    // Слот недоступен — показываем время номинально, но не в списке
                    currentStartTimeMinutes = clickedSlotMinutes;
                    if (startTimeWarning) startTimeWarning.style.display = 'inline-block';
                }
                
                // Инициализируем все селекты
                // Длительность: плейсхолдер "выберите период", список для времени начала
                var maxPeriodsForStart = clickedSlotAvailable ? clickedSlotMaxPeriods : globalMaxPeriods;
                rebuildDurationSelect(null, maxPeriodsForStart);
                // Передаём время начала, но оно может не быть в списке (номинальное отображение)
                rebuildStartTimeSelect(allStartSlots, currentStartTimeMinutes);
                
                // Время окончания: список "вправо" от времени начала (если доступно)
                var endTimes = clickedSlotAvailable 
                    ? getEndTimesForStartTime(clickedSlotMinutes) 
                    : getAllEndTimesForPeriods(1);
                rebuildEndTimeSelect(endTimes, null);
                
                updateSubmitButtonState();

                if (dateField) dateField.value = dateIso;
                if (timeField) timeField.value = timeHm;
            }
        }
    }

    // Счётчик символов для поля комментария
    document.addEventListener('DOMContentLoaded', function () {
        var textarea = document.getElementById('bookingComment');
        var counter = document.getElementById('bookingCommentCounter');
        var maxLength = 1000;

        if (!textarea || !counter) {
            return;
        }

        function updateCounter() {
            var val = textarea.value || '';

            if (val.length > maxLength) {
                textarea.value = val.slice(0, maxLength);
                val = textarea.value;
            }

            counter.textContent = val.length + '/' + maxLength;

            if (val.length >= maxLength) {
                counter.style.color = '#FF0000'; // красный
            } else if (val.length >= 900) {
                counter.style.color = '#FFA500'; // оранжевый
            } else {
                counter.style.color = '#818EA2'; // обычный
            }
        }

        textarea.addEventListener('input', updateCounter);
        updateCounter();
    });

    // Кастомные селекты только внутри этой модалки
    (function () {
        var modalElement = document.getElementById('createBookingModal');
        if (!modalElement) {
            return;
        }

        var teacherDirectionLastChanged = null;

        // --------------------------
        // Вспомогательные функции
        // --------------------------

        function getSelectedValue(selectEl) {
            var selectedLi = selectEl.querySelector('ul.options li.selected');
            return selectedLi ? (selectedLi.getAttribute('data-value') || '') : '';
        }

        function syncClearableSelectState(selectEl) {
            if (!selectEl || !selectEl.classList.contains('custom-select--clearable')) {
                return;
            }

            var hasValue = Boolean(getSelectedValue(selectEl));
            if (hasValue) {
                selectEl.classList.add('has-selection');
            } else {
                selectEl.classList.remove('has-selection');
            }
        }

        function resetSelect(selectEl) {
            var selectedSpan = selectEl.querySelector('.selected');
            var placeholder = selectEl.getAttribute('data-placeholder') || (selectedSpan ? selectedSpan.textContent : '');
            var options = selectEl.querySelectorAll('ul.options li');

            options.forEach(function (li) {
                li.classList.remove('selected');
            });

            if (selectedSpan) {
                selectedSpan.textContent = placeholder;
            }

            syncClearableSelectState(selectEl);
        }

        function resetTeacherDirectionUI() {
            var teacherSelect = modalElement.querySelector('#teacher');
            var directionSelect = modalElement.querySelector('#field-direction');
            if (!teacherSelect || !directionSelect) {
                return;
            }

            resetSelect(teacherSelect);
            resetSelect(directionSelect);

            teacherSelect.querySelectorAll('ul.options li').forEach(function (li) {
                li.style.display = '';
            });
            directionSelect.querySelectorAll('ul.options li').forEach(function (li) {
                li.style.display = '';
            });
        }

        function applyTeacherDirectionFilters() {
            var teacherSelect = modalElement.querySelector('#teacher');
            var directionSelect = modalElement.querySelector('#field-direction');
            if (!teacherSelect || !directionSelect) {
                return;
            }

            var selectedTeacherId = getSelectedValue(teacherSelect);
            var selectedDirectionId = getSelectedValue(directionSelect);

            var teacherLis = teacherSelect.querySelectorAll('ul.options li');
            var directionLis = directionSelect.querySelectorAll('ul.options li');

            // 1) Проверка на конфликт: если оба выбраны, но не совместимы — сбрасываем противоположный
            if (selectedTeacherId && selectedDirectionId) {
                var selectedTeacherLi = teacherSelect.querySelector('ul.options li.selected');
                var teacherDirectionsRaw = selectedTeacherLi ? (selectedTeacherLi.getAttribute('data-directions') || '') : '';
                var teacherDirections = teacherDirectionsRaw ? teacherDirectionsRaw.split(',').map(function (v) { return v.trim(); }).filter(Boolean) : [];

                if (teacherDirections.indexOf(String(selectedDirectionId)) === -1) {
                    if (teacherDirectionLastChanged === 'field-direction') {
                        resetSelect(teacherSelect);
                        selectedTeacherId = '';
                    } else {
                        resetSelect(directionSelect);
                        selectedDirectionId = '';
                    }
                }
            }

            // 2) Фильтрация направлений по выбранному преподавателю
            if (selectedTeacherId) {
                var teacherLi = teacherSelect.querySelector('ul.options li.selected');
                var dirsRaw = teacherLi ? (teacherLi.getAttribute('data-directions') || '') : '';
                var allowedDirs = dirsRaw ? dirsRaw.split(',').map(function (v) { return v.trim(); }).filter(Boolean) : [];

                directionLis.forEach(function (li) {
                    var dirId = li.getAttribute('data-value') || '';
                    li.style.display = allowedDirs.indexOf(String(dirId)) !== -1 ? '' : 'none';
                });
            } else {
                directionLis.forEach(function (li) {
                    li.style.display = '';
                });
            }

            // 3) Фильтрация преподавателей по выбранному направлению
            if (selectedDirectionId) {
                teacherLis.forEach(function (li) {
                    var dirsRaw = li.getAttribute('data-directions') || '';
                    var dirs = dirsRaw ? dirsRaw.split(',').map(function (v) { return v.trim(); }).filter(Boolean) : [];
                    li.style.display = dirs.indexOf(String(selectedDirectionId)) !== -1 ? '' : 'none';
                });
            } else {
                teacherLis.forEach(function (li) {
                    li.style.display = '';
                });
            }
        }

        function applyServicesFilters() {
            var servicesSelect = modalElement.querySelector('#services');
            if (!servicesSelect) {
                return;
            }

            var roomIdField = modalElement.querySelector('#roomIdField');
            var currentRoomId = roomIdField ? String(roomIdField.value || '') : '';
            var currentScenarioId = (window.currentScenarioFilterId !== undefined && window.currentScenarioFilterId !== null)
                ? String(window.currentScenarioFilterId)
                : '';

            // Фильтрация + защита от дублей:
            // Если по какой-то причине одинаковые услуги оказались добавлены несколько раз, оставляем только одну.
            // Ключ: service_id + room_id + scenario_id
            var options = servicesSelect.querySelectorAll('ul.options li');
            var seen = new Map();

            Array.from(options).forEach(function (li) {
                var liRoomId = String(li.getAttribute('data-room-id') || '');
                var liScenarioId = String(li.getAttribute('data-scenario-id') || '');
                var liValue = String(li.getAttribute('data-value') || '');

                var dedupeKey = liValue + '|' + liRoomId + '|' + liScenarioId;
                if (seen.has(dedupeKey)) {
                    var kept = seen.get(dedupeKey);

                    // Если выбран дубль, а сохранённый элемент не выбран — переносим выбранность на сохранённый.
                    if (li.classList.contains('selected') && kept && !kept.classList.contains('selected')) {
                        kept.classList.add('selected');

                        if (servicesSelect._selectedOptions) {
                            servicesSelect._selectedOptions.add(kept);
                            servicesSelect._selectedOptions.delete(li);
                        }
                    }

                    if (li.parentNode) {
                        li.parentNode.removeChild(li);
                    }
                    return;
                }
                seen.set(dedupeKey, li);

                var roomOk = !liRoomId || !currentRoomId || liRoomId === currentRoomId;
                var scenarioOk = !liScenarioId || !currentScenarioId || liScenarioId === currentScenarioId;

                li.style.display = (roomOk && scenarioOk) ? '' : 'none';
            });

            if (servicesSelect._selectedOptions && servicesSelect._selectedOptions.size) {
                var changed = false;
                Array.from(servicesSelect._selectedOptions).forEach(function (opt) {
                    if (opt.style.display === 'none') {
                        opt.classList.remove('selected');
                        servicesSelect._selectedOptions.delete(opt);
                        changed = true;
                    }
                });

                if (changed && typeof servicesSelect._updateSelectedText === 'function') {
                    servicesSelect._updateSelectedText();
                }
            }
        }

        applyServicesFilters();

        // --------------------------
        // Инициализация кастомных селектов
        // --------------------------
        var customSelects = Array.from(modalElement.querySelectorAll('.custom-select'));

        // Один глобальный обработчик закрытия по клику вне селекта (без навешивания N одинаковых слушателей)
        document.addEventListener('click', function (e) {
            customSelects.forEach(function (select) {
                if (!select.contains(e.target)) {
                    select.classList.remove('open');
                }
            });
        });

        customSelects.forEach(function (select) {
            var selected = select.querySelector('.selected');
            var optionsContainer = select.querySelector('.options');
            if (!selected || !optionsContainer) {
                return;
            }

            var optionsList = optionsContainer.querySelectorAll('li');
            var isClientSelect = select.id === 'client';
            var searchInput = isClientSelect ? select.querySelector('#client-search-input') : null;
            var searchOption = isClientSelect ? select.querySelector('#search-option') : null;

            var clearBtn = select.querySelector('.custom-select-clear');
            if (clearBtn) {
                clearBtn.addEventListener('click', function (e) {
                    e.preventDefault();
                    e.stopPropagation();

                    teacherDirectionLastChanged = select.id;
                    resetSelect(select);
                    select.classList.remove('open');

                    if (select.id === 'teacher' || select.id === 'field-direction') {
                        applyTeacherDirectionFilters();
                    }
                });
            }

            syncClearableSelectState(select);

            // Множественный выбор только для услуг (список не закрываем при выборе)
            if (select.id === 'services') {
                var selectedOptions = new Set();
                select._selectedOptions = selectedOptions;

                function updateSelectedText() {
                    if (selectedOptions.size === 0) {
                        selected.textContent = 'Выберите услугу';
                    } else if (selectedOptions.size === 1) {
                        selected.textContent = Array.from(selectedOptions)[0].textContent;
                    } else {
                        selected.textContent = selectedOptions.size + ' выбрано';
                    }
                }

                select._updateSelectedText = updateSelectedText;

                select.addEventListener('click', function (e) {
                    if (e.target.tagName !== 'LI') {
                        select.classList.toggle('open');
                    }
                });

                optionsList.forEach(function (option) {
                    option.addEventListener('mousedown', function (e) {
                        e.stopPropagation();
                    });
                    option.addEventListener('click', function (e) {
                        e.stopPropagation();
                        if (option.classList.contains('selected')) {
                            option.classList.remove('selected');
                            selectedOptions.delete(option);
                        } else {
                            option.classList.add('selected');
                            selectedOptions.add(option);
                        }

                        updateSelectedText();
                    });
                });

                return;
            }

            // Поиск по клиентам
            if (isClientSelect && searchInput) {
                searchInput.addEventListener('input', function () {
                    var filter = this.value.trim().toLowerCase();
                    optionsList.forEach(function (option) {
                        if (option.id === 'search-option') {
                            return;
                        }
                        var text = option.textContent.trim().toLowerCase();
                        option.style.display = text.indexOf(filter) !== -1 ? '' : 'none';
                    });
                });

                if (searchOption) {
                    // не даём выбрать пункт с поиском и не закрываем селект при клике по нему
                    searchOption.addEventListener('mousedown', function (e) {
                        e.stopPropagation();
                    });
                    searchOption.addEventListener('click', function (e) {
                        e.stopPropagation();
                    });
                }
            }

            // Обычный одиночный выбор (селект закрывается после выбора)
            select.addEventListener('click', function (e) {
                // не обрабатываем клики по option, они обрабатываются ниже
                if (e.target.tagName !== 'LI') {
                    select.classList.toggle('open');

                    // при открытии списка клиентов ставим фокус в поле поиска
                    if (isClientSelect && searchInput) {
                        setTimeout(function () {
                            searchInput.focus();
                        }, 0);
                    }
                }
            });

            optionsList.forEach(function (option) {
                // в селекте клиентов пункт с инпутом поиска не должен выбираться
                if (option.id === 'search-option') {
                    return;
                }

                option.addEventListener('click', function (e) {
                    e.stopPropagation();
                    optionsList.forEach(function (opt) { opt.classList.remove('selected'); });
                    option.classList.add('selected');
                    selected.textContent = option.textContent;
                    select.classList.remove('open');

                    syncClearableSelectState(select);

                    if (select.id === 'teacher' || select.id === 'field-direction') {
                        teacherDirectionLastChanged = select.id;
                        applyTeacherDirectionFilters();
                    }
                });
            });
        });

        // При закрытии модалки сбрасываем связанные селекты и фильтры, чтобы при следующем открытии не оставались скрытые элементы
        modalElement.addEventListener('hidden.bs.modal', function () {
            teacherDirectionLastChanged = null;
            resetTeacherDirectionUI();
        });

        // При открытии гарантируем корректную фильтрацию (на случай, если есть предустановленные значения)
        modalElement.addEventListener('shown.bs.modal', function () {
            applyTeacherDirectionFilters();
            applyServicesFilters();
        });
    })();
</script>