{% load custom_filters %}
{% load static %}

<head>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
</head>
<!-- Модальное окно создания брони -->
<p id="tariff_units_json" style="display: none;">{{ tariff_units_json }}</p>
<p id="services_json" style="display: none;">{{ services_json }}</p>
<p id="clients_json" style="display: none;">{{ clients_json }}</p>

<div class="modal fade" id="createBookingModal" tabindex="-1" aria-labelledby="createBookingModalLabel"
    aria-hidden="true" data-bs-backdrop="false">
    <div class="modal-dialog modal-dialog-centered" style="max-width:none; width: 63vw;">
        <div class="modal-content">
            <div class="modal-body">
                <form id="bookingForm" action="javascript:void(0);" method="POST">
                    {% csrf_token %}
                    <div class="mb-3">
                        <div class="row d-flex align-items-center mb-1">
                            <div class="col-md-12 d-flex justify-content-between align-items-center">
                                <h2 class="mb-0">Новая бронь</h2>
                                <button type="button" class="modal-close-icon" data-bs-dismiss="modal"
                                    aria-label="Закрыть">
                                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                                        xmlns="http://www.w3.org/2000/svg">
                                        <path d="M18 6L6 18" stroke="#7A52FF" stroke-width="2" stroke-linecap="round"
                                            stroke-linejoin="round" />
                                        <path d="M6 6L18 18" stroke="#7A52FF" stroke-width="2" stroke-linecap="round"
                                            stroke-linejoin="round" />
                                    </svg>
                                </button>
                            </div>
                        </div>
                        <div class="row mb-4">
                            <div id="roomNameContainer" class="col-md-6 align-items-center justify-content-start">
                                <span id="scenarioName">Название сценария</span> / <span id="roomName">Название
                                    комнаты</span>
                            </div>
                        </div>


                        <input type="hidden" id="dateField" name="date">
                        <input type="hidden" id="timeField" name="time">
                        <input type="hidden" id="roomNameField" name="room_name">
                        <input type="hidden" id="maxEndTime" name="maxEndTime">
                        <input type="hidden" id="fullDatetimeField">
                        <input type="hidden" id="roomIdField" name="room_id">
                    </div>

                    <div class="row mb-3">
                        <!--Выпадающий список "Клиент"-->
                        <div class="col-md-6">
                            <label for="client" class="form-label">Клиент</label>
                            <div class="custom-select" id="client" name="client">
                                <span class="selected">Выберите клиента</span>
                                <span class="chevron">
                                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                                        xmlns="http://www.w3.org/2000/svg">
                                        <path d="M6 9L12 15L18 9" stroke="#818EA2" stroke-width="2" />
                                    </svg>
                                </span>
                                <ul class="options">
                                    <li id="search-option" class="search-option" style="cursor:text;">
                                        <span style="display:flex;align-items:center;gap:6px;">
                                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                                                xmlns="http://www.w3.org/2000/svg">
                                                <path
                                                    d="M11 19C15.4183 19 19 15.4183 19 11C19 6.58172 15.4183 3 11 3C6.58172 3 3 6.58172 3 11C3 15.4183 6.58172 19 11 19Z"
                                                    stroke="#818EA2" stroke-width="2" stroke-linecap="round"
                                                    stroke-linejoin="round" />
                                                <path d="M21.0002 21L16.7002 16.7" stroke="#818EA2" stroke-width="2"
                                                    stroke-linecap="round" stroke-linejoin="round" />
                                            </svg>
                                            <input id="client-search-input" type="text" placeholder="Поиск"
                                                style="border:none;outline:none;background:transparent;width:120px;"
                                                autocomplete="off" />
                                        </span>
                                    </li>
                                    {% for client in clients %}
                                        <li data-value="{{ client.id }}">{{ client.name }}</li>
                                    {% endfor %}
                                </ul>
                            </div>
                        </div>

                        <!-- Выпадающий список "Направление" -->
                        <div class="col-md-6">
                            <label for="field-direction" class="form-label">Направление</label>
                            <div class="custom-select custom-select--clearable" id="field-direction" name="field-direction" data-placeholder="Выберите направление">
                                <span class="selected">Выберите направление</span>
                                <button type="button" class="custom-select-clear" aria-label="Сбросить выбор">×</button>
                                <span class="chevron">
                                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                                        xmlns="http://www.w3.org/2000/svg">
                                        <path d="M6 9L12 15L18 9" stroke="#818EA2" stroke-width="2" />
                                    </svg>
                                </span>
                                <ul class="options">
                                    {% for direction in directions %}
                                        <li data-value="{{ direction.id }}">{{ direction.name }}</li>
                                    {% endfor %}
                                </ul>
                            </div>
                        </div>
                    </div>

                    <div class="row mb-3">
                        <!--Строка информации об абонементе-->
                        <span id="abonementRow">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                                xmlns="http://www.w3.org/2000/svg">
                                <path
                                    d="M12.586 2.586C12.211 2.2109 11.7024 2.00011 11.172 2H4C3.46957 2 2.96086 2.21071 2.58579 2.58579C2.21071 2.96086 2 3.46957 2 4V11.172C2.00011 11.7024 2.2109 12.211 2.586 12.586L11.29 21.29C11.7445 21.7416 12.3592 21.9951 13 21.9951C13.6408 21.9951 14.2555 21.7416 14.71 21.29L21.29 14.71C21.7416 14.2555 21.9951 13.6408 21.9951 13C21.9951 12.3592 21.7416 11.7445 21.29 11.29L12.586 2.586Z"
                                    stroke="#EB5757" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                                <path
                                    d="M7.5 8C7.77614 8 8 7.77614 8 7.5C8 7.22386 7.77614 7 7.5 7C7.22386 7 7 7.22386 7 7.5C7 7.77614 7.22386 8 7.5 8Z"
                                    fill="#EB5757" stroke="#EB5757" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round" />
                            </svg>
                            <span>Aбонемент:</span>
                            <span>Название абонемента</span>
                            <span>/</span>
                            <span>Осталось занятий:</span>
                            <span>4</span>
                        </span>
                    </div>

                    <div class="row mb-3">
                        <!--Календарь дата-->
                        <div class="col-md-3">
                            <label for="modal-create-date" class="form-label">Дата</label>
                            <div class="modal-datepicker" id="modal-datepicker">
                                <input type="hidden" id="modal-create-date" name="modal-create-date" />
                                <div class="modal-datepicker__trigger" id="datepicker-trigger">
                                    <span id="datepicker-display">Выберите дату</span>
                                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <rect x="3" y="4" width="18" height="18" rx="2" stroke="#818EA2" stroke-width="2"/>
                                        <path d="M16 2V6" stroke="#818EA2" stroke-width="2" stroke-linecap="round"/>
                                        <path d="M8 2V6" stroke="#818EA2" stroke-width="2" stroke-linecap="round"/>
                                        <path d="M3 10H21" stroke="#818EA2" stroke-width="2"/>
                                    </svg>
                                </div>
                                <div class="modal-datepicker__popup" id="datepicker-popup">
                                    <div class="modal-datepicker__header">
                                        <button type="button" class="modal-datepicker__nav-btn" id="datepicker-prev">
                                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                                <path d="M15 18L9 12L15 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                            </svg>
                                        </button>
                                        <div class="modal-datepicker__selects">
                                            <select class="modal-datepicker__select" id="datepicker-month"></select>
                                            <select class="modal-datepicker__select" id="datepicker-year"></select>
                                        </div>
                                        <button type="button" class="modal-datepicker__nav-btn" id="datepicker-next">
                                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                                <path d="M9 18L15 12L9 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                            </svg>
                                        </button>
                                    </div>
                                    <div class="modal-datepicker__weekdays">
                                        <div class="modal-datepicker__weekday">Пн</div>
                                        <div class="modal-datepicker__weekday">Вт</div>
                                        <div class="modal-datepicker__weekday">Ср</div>
                                        <div class="modal-datepicker__weekday">Чт</div>
                                        <div class="modal-datepicker__weekday">Пт</div>
                                        <div class="modal-datepicker__weekday">Сб</div>
                                        <div class="modal-datepicker__weekday">Вс</div>
                                    </div>
                                    <div class="modal-datepicker__grid" id="datepicker-grid"></div>
                                    <div class="modal-datepicker__footer">
                                        <button type="button" class="modal-datepicker__today-btn" id="datepicker-today">Сегодня</button>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!--Выпадающий список Время начала-->
                        <div class="col-md-3">
                            <label for="start-time" class="form-label">Время начала</label>
                            <div class="custom-select custom-select--clearable" id="start-time" name="start-time" data-placeholder="Выберите время">
                                <span class="selected">Выберите время</span>
                                <button type="button" class="custom-select-clear" aria-label="Сбросить выбор">×</button>
                                <!-- Значок предупреждения о недоступном слоте -->
                                <span id="start-time-warning-icon" class="start-time-warning-icon" style="display: none;">
                                    <span class="warning-tooltip">Это время начала недоступно для выбранной даты.</span>
                                    ⚠
                                </span>
                                <span class="chevron">
                                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                                        xmlns="http://www.w3.org/2000/svg">
                                        <path d="M6 9L12 15L18 9" stroke="#818EA2" stroke-width="2" />
                                    </svg>
                                </span>
                                <ul class="options">
                                    <li data-value="1">10:00</li>
                                    <li data-value="2">11:00</li>
                                    <li data-value="3">12:00</li>
                                    <li data-value="4">13:00</li>
                                    <li data-value="5">14:00</li>
                                </ul>
                            </div>
                        </div>

                        <!--Выпадающий список Время окончания-->
                        <div class="col-md-3">
                            <label for="end-time" class="form-label">Время окончания</label>
                            <div class="custom-select custom-select--clearable" id="end-time" name="end-time" data-placeholder="Выберите время">
                                <span class="selected">Выберите время</span>
                                <button type="button" class="custom-select-clear" aria-label="Сбросить выбор">×</button>
                                <!-- Значок предупреждения о недоступном времени окончания -->
                                <span id="end-time-warning-icon" class="start-time-warning-icon" style="display: none;">
                                    <span class="warning-tooltip">Это время окончания недоступно для выбранной даты.</span>
                                    ⚠
                                </span>
                                <span class="chevron">
                                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                                        xmlns="http://www.w3.org/2000/svg">
                                        <path d="M6 9L12 15L18 9" stroke="#818EA2" stroke-width="2" />
                                    </svg>
                                </span>
                                <ul class="options">
                                    <li data-value="1">11:00</li>
                                    <li data-value="2">12:00</li>
                                    <li data-value="3">13:00</li>
                                    <li data-value="4">14:00</li>
                                    <li data-value="5">15:00</li>
                                </ul>
                            </div>
                        </div>

                        <!--Выпадающий список Длительность-->
                        <div class="col-md-3">
                            <label for="duration" class="form-label">Длительность</label>
                            <div class="custom-select custom-select--clearable" id="duration" name="duration" data-placeholder="Выберите длительность">
                                <span class="selected">Выберите длительность</span>
                                <button type="button" class="custom-select-clear" aria-label="Сбросить выбор">×</button>
                                <span class="chevron">
                                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                                        xmlns="http://www.w3.org/2000/svg">
                                        <path d="M6 9L12 15L18 9" stroke="#818EA2" stroke-width="2" />
                                    </svg>
                                </span>
                                <ul class="options">
                                    <li data-value="1">2 часа</li>
                                    <li data-value="2">3 часа</li>
                                    <li data-value="3">4 часа</li>
                                    <li data-value="4">5 часов</li>
                                    <li data-value="5">6 часов</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <div class="row mb-3">
                        <!--Выпадающий список Преподаватель-->
                        <div class="col-md-6">
                            <label for="teacher" class="form-label">Преподаватель</label>
                            <div class="custom-select custom-select--clearable" id="teacher" name="teacher" data-placeholder="Выберите преподавателя">
                                <span class="selected">Выберите преподавателя</span>
                                <span id="teacher-warning-icon" class="teacher-warning-icon" style="display: none;">
                                    <span class="warning-tooltip">Этот преподаватель занят в выбранное время.</span>
                                    ⚠
                                </span>
                                <button type="button" class="custom-select-clear" aria-label="Сбросить выбор">×</button>
                                <span class="chevron">
                                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                                        xmlns="http://www.w3.org/2000/svg">
                                        <path d="M6 9L12 15L18 9" stroke="#818EA2" stroke-width="2" />
                                    </svg>
                                </span>
                                <ul class="options">
                                    {% for specialist in specialists %}
                                        {% if specialist.active %}
                                            <li data-value="{{ specialist.id }}" data-directions="{% for direction in specialist.directions.all %}{{ direction.id }}{% if not forloop.last %},{% endif %}{% endfor %}">{{ specialist.name }}</li>
                                        {% endif %}
                                    {% endfor %}
                                </ul>
                            </div>
                        </div>

                        <!--Выпадающий список со множественным выбором Услуги-->
                        <div class="col-md-6">
                            <label for="services" class="form-label">Услуги (необязательно)</label>
                            <div class="custom-select" id="services" name="services">
                                <span class="selected">Выберите услугу</span>
                                <span class="chevron">
                                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                                        xmlns="http://www.w3.org/2000/svg">
                                        <path d="M6 9L12 15L18 9" stroke="#818EA2" stroke-width="2" />
                                    </svg>
                                </span>
                                <ul class="options">
                                    {% for service in services %}
                                        {% if service.active %}
                                            <li data-value="{{ service.id }}" data-scenario-id="{{ service.scenario_id|default_if_none:'' }}" data-room-id="{{ service.room_id|default_if_none:'' }}">{{ service.name }}</li>
                                        {% endif %}
                                    {% endfor %}
                                </ul>
                            </div>
                        </div>
                    </div>

                    <!--Комментарий-->
                    <div class="row mb-3">
                        <div class="col-md-12">
                            <label for="bookingComment" class="form-label">Комментарий</label>
                            <textarea class="form-control" id="bookingComment" name="bookingComment" rows="3"
                                placeholder="Добавьте комментарий" maxlength="1000"></textarea>
                            <div class="char-counter" id="bookingCommentCounter">0/1000</div>
                        </div>
                    </div>

                    <!--Чекбокс пробное занятие-->
                    <div class="row mb-5">
                        <div class="col-md-12 trial-checkbox-row">
                            <input class="form-check-input" type="checkbox" id="trialLessonCheckbox" name="trialLesson">
                            <label class="form-check-label" for="trialLessonCheckbox" id="trialLessonLabel">
                                Пробное занятие
                            </label>
                        </div>
                    </div>

                    <!--Расчетная стоимость-->
                    <div class="row mb-4">
                        <div class="col-md-3">
                            <div class="d-flex align-items-end" style="height: 100%;">
                                <label for="bookingCostValue" class="form-label mb-0">Расчётная стоимость:</label>
                            </div>
                        </div>
                        <div class="col-md-3">
                            <div class="d-flex align-items-end justify-content-end" style="height: 100%;">
                                <span id="bookingCostValue">0 BYN</span>
                            </div>
                        </div>
                    </div>

                    <!--Кнопки Добавить и Отмена-->
                    <div class="row mb-3">
                        <div class="col-md-3">
                            <button type="button" class="button-primary" id="createBookingSubmitBtn">Добавить</button>
                        </div>
                        <div class="col-md-3">
                            <button type="button" class="button-sec" data-bs-dismiss="modal">Отмена</button>
                        </div>
                    </div>


                </form>
            </div>
            <!-- Значок предупреждения в нижнем правом углу модалки -->
            <span id="submit-warning-icon" class="submit-warning-icon" style="display: none;">
                <span class="submit-warning-tooltip">
                    <ul id="submit-checklist"></ul>
                </span>
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 9V13" stroke="#E53935" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M12 17H12.01" stroke="#E53935" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M10.29 3.86L1.82 18C1.64 18.3 1.55 18.64 1.55 19C1.55 19.36 1.64 19.7 1.82 20C2 20.3 2.26 20.56 2.56 20.74C2.86 20.92 3.2 21.01 3.55 21H20.45C20.8 21.01 21.14 20.92 21.44 20.74C21.74 20.56 22 20.3 22.18 20C22.36 19.7 22.45 19.36 22.45 19C22.45 18.64 22.36 18.3 22.18 18L13.71 3.86C13.53 3.56 13.27 3.32 12.97 3.15C12.67 2.98 12.34 2.89 12 2.89C11.66 2.89 11.33 2.98 11.03 3.15C10.73 3.32 10.47 3.56 10.29 3.86Z" stroke="#E53935" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </span>
        </div>
    </div>
</div>

<script>
    // JS модалки создания брони

    // Функция открытия модального окна: подставляет комнату и сценарий в шапку + базовые hidden-поля
    function openModal(date, time, roomName, roomId, cell) {
        // Сбрасываем комментарий при каждом открытии
        var commentField = document.getElementById('bookingComment');
        if (commentField) {
            commentField.value = '';
        }
        var commentCounter = document.getElementById('bookingCommentCounter');
        if (commentCounter) {
            commentCounter.textContent = '0/1000';
        }
        
        // Комната
        var roomNameSpan = document.getElementById('roomName');
        if (roomNameSpan) {
            roomNameSpan.textContent = roomName;
        }

        // Сценарий: берём из глобального фильтра window.currentScenarioFilterId + window.SCENARIOS (из user_index.html)
        if (window.currentScenarioFilterId && Array.isArray(window.SCENARIOS)) {
            var scenarioId = String(window.currentScenarioFilterId);
            var scenarioObj = window.SCENARIOS.find(function (s) { return String(s.pk) === scenarioId; });
            var scenarioNameSpan = document.getElementById('scenarioName');
            if (scenarioNameSpan) {
                scenarioNameSpan.textContent = (scenarioObj && scenarioObj.fields && scenarioObj.fields.name)
                    ? scenarioObj.fields.name
                    : 'Название сценария';
            }
        }

        // Базовые скрытые поля (если нужны бэкенду)
        var dateField = document.getElementById('dateField');
        var timeField = document.getElementById('timeField');
        var roomNameField = document.getElementById('roomNameField');
        var roomIdField = document.getElementById('roomIdField');
        var fullDatetimeField = document.getElementById('fullDatetimeField');

        var fullDatetimeStr = (cell && typeof cell.getAttribute === 'function')
            ? (cell.getAttribute('full_datetime') || '')
            : '';

        if (dateField) dateField.value = date;
        if (timeField) timeField.value = time;
        if (roomNameField) roomNameField.value = roomName;
        if (roomIdField) roomIdField.value = roomId;

        if (fullDatetimeField) {
            fullDatetimeField.value = fullDatetimeStr;
        }

        // Видимые поля
        if (fullDatetimeStr) {
            var dtParts = fullDatetimeStr.split(' ');
            if (dtParts.length >= 2) {
                var dateIso = dtParts[0];
                var timeRaw = dtParts[1];
                var timeParts = String(timeRaw).split(':');
                var timeHm = timeParts.length >= 2 ? (timeParts[0] + ':' + timeParts[1]) : String(timeRaw);

                var modalDateInput = document.getElementById('modal-create-date');
                if (modalDateInput) {
                    modalDateInput.value = dateIso;
                }

                // =====================================================
                // МОДУЛЬ УПРАВЛЕНИЯ ВРЕМЕНЕМ БРОНИ
                // =====================================================
                // 
                // Управляет тремя связанными селектами:
                // - Время начала (start-time)
                // - Длительность (duration) — в периодах по minMinutes минут
                // - Время окончания (end-time)
                //
                // ЛОГИКА ВЗАИМОДЕЙСТВИЯ:
                // 1. При выборе времени начала:
                //    - Список окончаний формируется "вправо" от начала
                //    - Если есть окончание — вычисляется длительность
                //
                // 2. При выборе времени окончания:
                //    - Список начала формируется "влево" от окончания
                //    - Если есть начало — вычисляется длительность
                //
                // 3. При выборе длительности:
                //    - Списки начала/окончания фильтруются по длительности
                //    - Если есть начало — подставляется окончание
                //    - Если есть окончание — подставляется начало
                //
                // 4. Кнопка "Добавить" активна только когда выбраны
                //    и время начала, и время окончания
                // =====================================================

                // --- Вспомогательные функции: получение данных сценария ---

                // Получить минимальную длительность периода из текущего сценария (в минутах)
                // Данные берутся из TariffUnit.min_reservation_time (TimeField в формате "HH:MM:SS")
                function getScenarioMinDurationMinutes() {
                    var fallback = 60;
                    if (!window.currentScenarioFilterId || !Array.isArray(window.TARIFF_UNITS)) {
                        return fallback;
                    }
                    var scenarioId = String(window.currentScenarioFilterId);
                    
                    // Ищем тарифную единицу для текущего сценария
                    var tariffUnit = window.TARIFF_UNITS.find(function (t) {
                        return t.fields && String(t.fields.scenario) === scenarioId;
                    });
                    
                    if (!tariffUnit || !tariffUnit.fields || !tariffUnit.fields.min_reservation_time) {
                        return fallback;
                    }
                    // Парсим TimeField формат "HH:MM:SS" в минуты
                    var timeParts = String(tariffUnit.fields.min_reservation_time).split(':');
                    if (timeParts.length < 2) return fallback;
                    var hours = parseInt(timeParts[0], 10);
                    var minutes = parseInt(timeParts[1], 10);
                    if (isNaN(hours) || isNaN(minutes)) return fallback;
                    var totalMinutes = hours * 60 + minutes;
                    return totalMinutes > 0 ? totalMinutes : fallback;
                }
                // Делаем функцию доступной глобально
                window.getScenarioMinDurationMinutes = getScenarioMinDurationMinutes;

                // Получить work_time_start сценария в минутах от полуночи
                function getScenarioWorkTimeStartMinutes() {
                    if (!window.currentScenarioFilterId || !Array.isArray(window.SCENARIOS)) {
                        return 0;
                    }
                    var scenarioId = String(window.currentScenarioFilterId);
                    var scenarioObj = window.SCENARIOS.find(function (s) { return String(s.pk) === scenarioId; });
                    if (!scenarioObj || !scenarioObj.fields || !scenarioObj.fields.work_time_start) {
                        return 0;
                    }
                    var parts = String(scenarioObj.fields.work_time_start).split(':');
                    if (parts.length < 2) return 0;
                    var h = parseInt(parts[0], 10);
                    var m = parseInt(parts[1], 10);
                    if (isNaN(h) || isNaN(m)) return 0;
                    return h * 60 + m;
                }

                // Получить work_time_end сценария в минутах от полуночи
                function getScenarioWorkTimeEndMinutes() {
                    if (!window.currentScenarioFilterId || !Array.isArray(window.SCENARIOS)) {
                        return 24 * 60;
                    }
                    var scenarioId = String(window.currentScenarioFilterId);
                    var scenarioObj = window.SCENARIOS.find(function (s) { return String(s.pk) === scenarioId; });
                    if (!scenarioObj || !scenarioObj.fields || !scenarioObj.fields.work_time_end) {
                        return 24 * 60;
                    }
                    var parts = String(scenarioObj.fields.work_time_end).split(':');
                    if (parts.length < 2) return 24 * 60;
                    var h = parseInt(parts[0], 10);
                    var m = parseInt(parts[1], 10);
                    if (isNaN(h) || isNaN(m)) return 24 * 60;
                    return h * 60 + m;
                }

                // Получить стоимость одного периода (тарифной единицы) для текущего сценария
                function getScenarioTariffUnitCost() {
                    if (!window.currentScenarioFilterId || !Array.isArray(window.TARIFF_UNITS)) {
                        return 0;
                    }
                    var scenarioId = String(window.currentScenarioFilterId);
                    var tariffUnit = window.TARIFF_UNITS.find(function (t) {
                        return t.fields && String(t.fields.scenario) === scenarioId;
                    });
                    if (!tariffUnit || !tariffUnit.fields || !tariffUnit.fields.tariff_unit_cost) {
                        return 0;
                    }
                    return parseFloat(tariffUnit.fields.tariff_unit_cost) || 0;
                }

                // Получить сумму стоимости выбранных услуг
                function getSelectedServicesCost() {
                    var servicesSelect = document.getElementById('services');
                    if (!servicesSelect || !servicesSelect._selectedOptions || servicesSelect._selectedOptions.size === 0) {
                        return 0;
                    }
                    // Парсим JSON с услугами
                    var servicesJsonEl = document.getElementById('services_json');
                    if (!servicesJsonEl) return 0;
                    var servicesData;
                    try {
                        servicesData = JSON.parse(servicesJsonEl.textContent || '[]');
                    } catch (e) {
                        return 0;
                    }
                    
                    var totalCost = 0;
                    servicesSelect._selectedOptions.forEach(function (li) {
                        var serviceId = li.getAttribute('data-value');
                        if (!serviceId) return;
                        var service = servicesData.find(function (s) {
                            return String(s.pk) === String(serviceId);
                        });
                        if (service && service.fields && service.fields.cost) {
                            totalCost += parseFloat(service.fields.cost) || 0;
                        }
                    });
                    return totalCost;
                }

                // Рассчитать и обновить стоимость брони
                // Стоимость = (кол-во периодов × стоимость периода) + сумма услуг
                function calculateAndUpdateBookingCost() {
                    var costElement = document.getElementById('bookingCostValue');
                    if (!costElement) return;
                    
                    // Если длительность не выбрана — стоимость 0
                    if (currentSelectedPeriods === null || currentSelectedPeriods === undefined) {
                        costElement.textContent = '0 BYN';
                        return;
                    }
                    
                    var periodCost = getScenarioTariffUnitCost();
                    var periodsTotalCost = currentSelectedPeriods * periodCost;
                    var servicesCost = getSelectedServicesCost();
                    var totalCost = periodsTotalCost + servicesCost;
                    
                    // Форматируем с 2 знаками после запятой, убираем лишние нули
                    var formatted = totalCost.toFixed(2).replace(/\.00$/, '');
                    costElement.textContent = formatted + ' BYN';
                }
                // Делаем функцию доступной глобально для вызова из других блоков кода
                window.calculateAndUpdateBookingCost = calculateAndUpdateBookingCost;

                // Преобразовать datetime строку "YYYY-MM-DD HH:MM:SS" в объект Date
                function parseDatetimeStr(dtStr) {
                    if (!dtStr) return null;
                    var parts = dtStr.split(' ');
                    if (parts.length < 2) return null;
                    var dateParts = parts[0].split('-');
                    var timeParts = parts[1].split(':');
                    if (dateParts.length < 3 || timeParts.length < 2) return null;
                    return new Date(
                        parseInt(dateParts[0], 10),
                        parseInt(dateParts[1], 10) - 1,
                        parseInt(dateParts[2], 10),
                        parseInt(timeParts[0], 10),
                        parseInt(timeParts[1], 10),
                        timeParts[2] ? parseInt(timeParts[2], 10) : 0
                    );
                }

                // Форматирование времени из минут от полуночи в HH:MM
                function formatTimeHHMM(totalMinutes) {
                    var m = parseInt(totalMinutes, 10);
                    if (isNaN(m) || m < 0) return '';
                    var h = Math.floor(m / 60) % 24;
                    var mm = m % 60;
                    return String(h).padStart(2, '0') + ':' + String(mm).padStart(2, '0');
                }

                // Парсинг времени HH:MM в минуты от полуночи
                function parseTimeToMinutes(timeStr) {
                    if (!timeStr) return 0;
                    var parts = String(timeStr).split(':');
                    if (parts.length < 2) return 0;
                    return parseInt(parts[0], 10) * 60 + parseInt(parts[1], 10);
                }

                // Форматирование длительности для отображения
                function formatDurationHuman(totalMinutes) {
                    var m = parseInt(totalMinutes, 10);
                    if (isNaN(m) || m <= 0) return '';
                    var h = Math.floor(m / 60);
                    var mm = m % 60;
                    if (h > 0 && mm > 0) return h + ' ч ' + mm + ' мин';
                    if (h > 0) return h + ' ч';
                    return mm + ' мин';
                }

                // Форматирование длительности в HH:MM для отправки на сервер
                function formatDurationHHMM(totalMinutes) {
                    var m = parseInt(totalMinutes, 10);
                    if (isNaN(m) || m < 0) return '';
                    var h = Math.floor(m / 60);
                    var mm = m % 60;
                    return String(h).padStart(2, '0') + ':' + String(mm).padStart(2, '0');
                }

                // Склонение слова "период"
                function formatPeriodsLabel(n) {
                    var k = parseInt(n, 10);
                    if (k === 1) return 'период';
                    if (k >= 2 && k <= 4) return 'периода';
                    return 'периодов';
                }

                // Кэш броней комнаты на дату (загружается через AJAX, содержит ВСЕ брони комнаты без фильтра по сценарию)
                var roomBookingsCache = {
                    roomId: null,
                    date: null,
                    bookings: []
                };
                
                // Загрузить все брони комнаты на дату через AJAX (без фильтра по сценарию)
                function loadRoomBookingsForDate(roomId, dateIso, callback) {
                    // Приводим roomId к строке для корректного сравнения
                    var roomIdStr = String(roomId);
                    
                    // Проверяем кэш
                    if (roomBookingsCache.roomId === roomIdStr && roomBookingsCache.date === dateIso) {
                        if (callback) callback(roomBookingsCache.bookings);
                        return;
                    }
                    
                    var url = '/booking/room-bookings-for-date/?room_id=' + encodeURIComponent(roomId) + '&date=' + encodeURIComponent(dateIso);
                    
                    fetch(url, {
                        method: 'GET',
                        headers: {
                            'X-Requested-With': 'XMLHttpRequest'
                        }
                    })
                    .then(function(response) {
                        return response.json();
                    })
                    .then(function(data) {
                        if (data.success && Array.isArray(data.bookings)) {
                            // Преобразуем в формат {startMinutes, endMinutes}
                            var parsed = [];
                            data.bookings.forEach(function(booking) {
                                if (!booking.blocks_datetime_range || !booking.blocks_datetime_range.length) return;
                                
                                // Фильтруем только блоки на запрошенную дату
                                var blocksOnDate = booking.blocks_datetime_range.filter(function(block) {
                                    return block.startsWith(dateIso);
                                });
                                
                                if (blocksOnDate.length === 0) return;
                                
                                var startDt = parseDatetimeStr(blocksOnDate[0]);
                                var endDt = parseDatetimeStr(blocksOnDate[blocksOnDate.length - 1]);
                                if (!startDt || !endDt) return;
                                
                                // Добавляем 15 минут к endDt, т.к. последний блок - это начало последнего 15-мин интервала
                                var endMinutes = endDt.getHours() * 60 + endDt.getMinutes() + 15;
                                
                                parsed.push({
                                    startMinutes: startDt.getHours() * 60 + startDt.getMinutes(),
                                    endMinutes: endMinutes
                                });
                            });
                            
                            // Сохраняем в кэш
                            roomBookingsCache.roomId = roomIdStr;
                            roomBookingsCache.date = dateIso;
                            roomBookingsCache.bookings = parsed;
                            
                            if (callback) callback(parsed);
                        } else {
                            console.error('Ошибка загрузки броней комнаты:', data.error || 'unknown');
                            if (callback) callback([]);
                        }
                    })
                    .catch(function(error) {
                        console.error('Сетевая ошибка при загрузке броней комнаты:', error);
                        if (callback) callback([]);
                    });
                }
                
                // --- Кэш занятых специалистов на дату ---
                var busySpecialistsCache = {
                    date: null,
                    specialists: [] // [{id, name, intervals: [{startMinutes, endMinutes}]}]
                };
                
                // Загрузить занятых специалистов на дату через AJAX
                function loadBusySpecialistsForDate(dateIso, callback) {
                    // Проверяем кэш
                    if (busySpecialistsCache.date === dateIso) {
                        if (callback) callback(busySpecialistsCache.specialists);
                        return;
                    }
                    
                    var url = '/booking/busy-specialists-for-date/?date=' + encodeURIComponent(dateIso);
                    
                    fetch(url, {
                        method: 'GET',
                        headers: {
                            'X-Requested-With': 'XMLHttpRequest'
                        }
                    })
                    .then(function(response) {
                        return response.json();
                    })
                    .then(function(data) {
                        if (data.success && Array.isArray(data.busy_specialists)) {
                            busySpecialistsCache.date = dateIso;
                            busySpecialistsCache.specialists = data.busy_specialists;
                            if (callback) callback(data.busy_specialists);
                        } else {
                            console.error('Ошибка загрузки занятых специалистов:', data.error || 'unknown');
                            if (callback) callback([]);
                        }
                    })
                    .catch(function(error) {
                        console.error('Сетевая ошибка при загрузке занятых специалистов:', error);
                        if (callback) callback([]);
                    });
                }
                
                // Проверить, занят ли специалист в указанное время
                function isSpecialistBusy(specialistId, startMinutes, endMinutes) {
                    var busySpecs = busySpecialistsCache.specialists || [];
                    for (var i = 0; i < busySpecs.length; i++) {
                        if (busySpecs[i].id === specialistId) {
                            var intervals = busySpecs[i].intervals || [];
                            for (var j = 0; j < intervals.length; j++) {
                                var interval = intervals[j];
                                // Пересечение: (start1 < end2) && (end1 > start2)
                                if (startMinutes < interval.endMinutes && endMinutes > interval.startMinutes) {
                                    return true;
                                }
                            }
                            break;
                        }
                    }
                    return false;
                }
                // Делаем функцию доступной глобально
                window.isSpecialistBusy = isSpecialistBusy;
                
                // Получить список доступных специалистов для выбранного времени
                function getAvailableSpecialistIds(startMinutes, endMinutes) {
                    var busySpecs = busySpecialistsCache.specialists || [];
                    var busyIds = [];
                    for (var i = 0; i < busySpecs.length; i++) {
                        if (isSpecialistBusy(busySpecs[i].id, startMinutes, endMinutes)) {
                            busyIds.push(busySpecs[i].id);
                        }
                    }
                    return busyIds;
                }
                
                // Получить все брони в комнате на выбранную дату (из кэша)
                function getRoomBookingsForDate(currentRoomId, dateIso) {
                    // Возвращаем из кэша (должен быть уже загружен через loadRoomBookingsForDate)
                    if (roomBookingsCache.roomId === String(currentRoomId) && roomBookingsCache.date === dateIso) {
                        return roomBookingsCache.bookings;
                    }
                    // Fallback на старый способ если кэш пуст
                    var bookings = window.bookingsInRange || (typeof bookingsInRange !== 'undefined' ? bookingsInRange : []);
                    if (!Array.isArray(bookings)) return [];
                    
                    var result = [];
                    bookings.forEach(function (booking) {
                        if (String(booking.idroom) !== String(currentRoomId)) return;
                        if (!booking.blocks_datetime_range || !booking.blocks_datetime_range.length) return;
                        
                        // Фильтруем только блоки на запрошенную дату
                        var blocksOnDate = booking.blocks_datetime_range.filter(function(block) {
                            return block.startsWith(dateIso);
                        });
                        
                        if (blocksOnDate.length === 0) return;
                        
                        var startDt = parseDatetimeStr(blocksOnDate[0]);
                        var endDt = parseDatetimeStr(blocksOnDate[blocksOnDate.length - 1]);
                        if (!startDt || !endDt) return;
                        
                        var startMinutes = startDt.getHours() * 60 + startDt.getMinutes();
                        // Добавляем 15 минут к endMinutes, т.к. последний блок - это начало последнего 15-мин интервала
                        var endMinutes = endDt.getHours() * 60 + endDt.getMinutes() + 15;
                        
                        result.push({
                            startMinutes: startMinutes,
                            endMinutes: endMinutes
                        });
                    });
                    return result;
                }

                // Вычислить доступные слоты времени начала для комнаты на дату
                // Шаг = 15 минут (шаг сетки календаря), слот доступен если есть minMinutes до брони/конца дня
                function getAvailableStartTimeSlots(currentRoomId, dateIso) {
                    var minMinutes = getScenarioMinDurationMinutes();
                    var workStart = getScenarioWorkTimeStartMinutes();
                    var workEnd = getScenarioWorkTimeEndMinutes();
                    var roomBookings = getRoomBookingsForDate(currentRoomId, dateIso);
                    var gridStep = 15; // Шаг сетки календаря в минутах
                    
                    var slots = [];
                    
                    // Сортируем брони по времени начала
                    roomBookings.sort(function (a, b) { return a.startMinutes - b.startMinutes; });
                    
                    // Перебираем все временные слоты с шагом 15 минут
                    for (var currentTime = workStart; currentTime + minMinutes <= workEnd; currentTime += gridStep) {
                        var isBlocked = false;
                        
                        // Проверяем, не попадает ли слот внутрь существующей брони
                        for (var i = 0; i < roomBookings.length; i++) {
                            var booking = roomBookings[i];
                            
                            // Слот блокирован, если он начинается во время брони
                            if (currentTime >= booking.startMinutes && currentTime < booking.endMinutes) {
                                isBlocked = true;
                                break;
                            }
                            
                            // Слот блокирован, если минимальная бронь не помещается до начала следующей брони
                            if (currentTime < booking.startMinutes && currentTime + minMinutes > booking.startMinutes) {
                                isBlocked = true;
                                break;
                            }
                        }
                        
                        if (!isBlocked) {
                            slots.push(currentTime);
                        }
                    }
                    
                    return slots;
                }

                // Вычислить максимальное количество периодов для заданного времени начала
                function getMaxPeriodsForStartTime(startTimeMinutes, currentRoomId, dateIso) {
                    var minMinutes = getScenarioMinDurationMinutes();
                    var workEnd = getScenarioWorkTimeEndMinutes();
                    var roomBookings = getRoomBookingsForDate(currentRoomId, dateIso);
                    
                    // Ограничение 0: проверяем, что время начала не попадает внутрь существующей брони
                    for (var i = 0; i < roomBookings.length; i++) {
                        var booking = roomBookings[i];
                        if (startTimeMinutes >= booking.startMinutes && startTimeMinutes < booking.endMinutes) {
                            // Время начала внутри брони — недоступно
                            return 0;
                        }
                    }
                    
                    // Ограничение 1: до конца рабочего времени
                    var minutesToWorkEnd = workEnd - startTimeMinutes;
                    if (minutesToWorkEnd <= 0) return 0;
                    
                    // Ограничение 2: до следующей брони
                    var minutesToNextBooking = null;
                    roomBookings.forEach(function (booking) {
                        if (booking.startMinutes > startTimeMinutes) {
                            var diff = booking.startMinutes - startTimeMinutes;
                            if (minutesToNextBooking === null || diff < minutesToNextBooking) {
                                minutesToNextBooking = diff;
                            }
                        }
                    });
                    
                    // Итоговое ограничение
                    var availableMinutes = minutesToWorkEnd;
                    if (minutesToNextBooking !== null) {
                        availableMinutes = Math.min(availableMinutes, minutesToNextBooking);
                    }
                    
                    return Math.floor(availableMinutes / minMinutes);
                }

                // --- Состояние модуля ---
                // Длительность — главный показатель. Списки начала/конца формируются по ней.
                var currentRoomId = roomIdField ? roomIdField.value : roomId;
                var minMinutes = getScenarioMinDurationMinutes();
                var clickedSlotMinutes = parseTimeToMinutes(timeHm);
                
                // Текущие выбранные значения (null = не выбрано, показывается placeholder)
                // Используем window для доступа из других IIFE
                var currentStartTimeMinutes = null;
                var currentSelectedPeriods = 1;
                var currentEndTimeMinutes = null;
                
                // Функции для синхронизации с глобальными переменными
                function setStartTimeMinutes(val) {
                    currentStartTimeMinutes = val;
                    window.currentStartTimeMinutes = val;
                }
                function setEndTimeMinutes(val) {
                    currentEndTimeMinutes = val;
                    window.currentEndTimeMinutes = val;
                }
                // Инициализация глобальных переменных
                window.currentStartTimeMinutes = null;
                window.currentEndTimeMinutes = null;

                // --- DOM элементы ---
                var startTimeSelect = document.getElementById('start-time');
                var durationSelect = document.getElementById('duration');
                var endTimeSelect = document.getElementById('end-time');
                var submitBtn = document.getElementById('createBookingSubmitBtn');

                // --- Функции формирования списков времени ---

                // Получить слоты времени начала, с которых доступно >= requiredPeriods периодов
                function getStartTimeSlotsForPeriods(requiredPeriods) {
                    var allSlots = getAvailableStartTimeSlots(currentRoomId, dateIso);
                    if (requiredPeriods <= 1) return allSlots;
                    
                    return allSlots.filter(function (slotMinutes) {
                        var maxPeriods = getMaxPeriodsForStartTime(slotMinutes, currentRoomId, dateIso);
                        return maxPeriods >= requiredPeriods;
                    });
                }

                // Получить все возможные времена окончания для заданного кол-ва периодов (глобально)
                function getAllEndTimesForPeriods(requiredPeriods) {
                    var slots = getStartTimeSlotsForPeriods(requiredPeriods);
                    var endTimes = [];
                    var duration = minMinutes * requiredPeriods;
                    
                    slots.forEach(function (startMinutes) {
                        var endMinutes = startMinutes + duration;
                        if (endTimes.indexOf(endMinutes) === -1) {
                            endTimes.push(endMinutes);
                        }
                    });
                    
                    endTimes.sort(function (a, b) { return a - b; });
                    return endTimes;
                }

                // Получить времена окончания "вправо" от заданного времени начала (для конкретного слота)
                function getEndTimesForStartTime(startTimeMinutes) {
                    var maxPeriods = getMaxPeriodsForStartTime(startTimeMinutes, currentRoomId, dateIso);
                    var endTimes = [];
                    
                    for (var p = 1; p <= maxPeriods; p++) {
                        var endMinutes = startTimeMinutes + (minMinutes * p);
                        endTimes.push(endMinutes);
                    }
                    
                    return endTimes;
                }

                // Получить времена начала "влево" от заданного времени окончания (для конкретного слота)
                function getStartTimesForEndTime(endTimeMinutes) {
                    var allSlots = getStartTimeSlotsForPeriods(1);
                    var startTimes = [];
                    
                    allSlots.forEach(function (slotMinutes) {
                        if (slotMinutes < endTimeMinutes) {
                            var maxPeriods = getMaxPeriodsForStartTime(slotMinutes, currentRoomId, dateIso);
                            var maxEndTime = slotMinutes + (minMinutes * maxPeriods);
                            // Проверяем, что с этого слота можно дойти до нужного времени окончания
                            if (maxEndTime >= endTimeMinutes) {
                                startTimes.push(slotMinutes);
                            }
                        }
                    });
                    
                    startTimes.sort(function (a, b) { return a - b; });
                    return startTimes;
                }

                // --- Вычислить глобальное максимальное количество периодов ---
                function getGlobalMaxPeriods() {
                    var allSlots = getStartTimeSlotsForPeriods(1);
                    var maxPeriods = 0;
                    allSlots.forEach(function (slotMinutes) {
                        var mp = getMaxPeriodsForStartTime(slotMinutes, currentRoomId, dateIso);
                        if (mp > maxPeriods) maxPeriods = mp;
                    });
                    return maxPeriods;
                }

                // --- Вычислить максимальное количество периодов для времени окончания ---
                function getMaxPeriodsForEndTime(endTimeMinutes) {
                    var startTimesForEnd = getStartTimesForEndTime(endTimeMinutes);
                    var maxPeriods = 0;
                    for (var p = 1; p <= 20; p++) {
                        var potentialStart = endTimeMinutes - (minMinutes * p);
                        if (startTimesForEnd.indexOf(potentialStart) !== -1) {
                            maxPeriods = p;
                        }
                    }
                    return maxPeriods;
                }

                // --- Функции управления UI ---

                // Активирует/деактивирует кнопку "Добавить" в зависимости от заполненности полей и предупреждений
                function updateSubmitButtonState() {
                    if (!submitBtn) return;
                    
                    var checklist = [];
                    var hasStartTime = currentStartTimeMinutes !== null;
                    var hasEndTime = currentEndTimeMinutes !== null;
                    
                    // Проверяем наличие предупреждений
                    var startTimeWarning = document.getElementById('start-time-warning-icon');
                    var endTimeWarning = document.getElementById('end-time-warning-icon');
                    var teacherWarning = document.getElementById('teacher-warning-icon');
                    var hasStartWarning = startTimeWarning && startTimeWarning.style.display !== 'none';
                    var hasEndWarning = endTimeWarning && endTimeWarning.style.display !== 'none';
                    var hasTeacherWarning = teacherWarning && teacherWarning.style.display !== 'none';
                    
                    // Проверяем преподавателя, направление и клиента
                    var teacherSelect = document.getElementById('teacher');
                    var directionSelect = document.getElementById('field-direction');
                    var clientSelect = document.getElementById('client');
                    var teacherSelectedLi = teacherSelect ? teacherSelect.querySelector('ul.options li.selected') : null;
                    var directionSelectedLi = directionSelect ? directionSelect.querySelector('ul.options li.selected') : null;
                    var clientSelectedLi = clientSelect ? clientSelect.querySelector('ul.options li.selected:not(#search-option)') : null;
                    var hasTeacher = teacherSelectedLi !== null;
                    var hasDirection = directionSelectedLi !== null;
                    var hasClient = clientSelectedLi !== null && clientSelectedLi.getAttribute('data-value');
                    
                    // Формируем чек-лист
                    if (!hasStartTime) {
                        checklist.push('Выберите время начала');
                    } else if (hasStartWarning) {
                        checklist.push('Выберите доступное время начала');
                    }
                    
                    if (!hasEndTime) {
                        checklist.push('Выберите время окончания');
                    } else if (hasEndWarning) {
                        checklist.push('Выберите доступное время окончания');
                    }
                    
                    if (!hasTeacher) {
                        checklist.push('Выберите преподавателя');
                    } else if (hasTeacherWarning) {
                        checklist.push('Выберите доступного преподавателя');
                    }
                    
                    if (!hasDirection) {
                        checklist.push('Выберите направление');
                    }
                    
                    if (!hasClient) {
                        checklist.push('Выберите клиента');
                    }
                    
                    // Обновляем чек-лист в тултипе
                    var submitWarning = document.getElementById('submit-warning-icon');
                    var submitChecklist = document.getElementById('submit-checklist');
                    
                    if (checklist.length > 0) {
                        // Кнопка неактивна
                        submitBtn.disabled = true;
                        if (submitWarning) submitWarning.style.display = 'inline-block';
                        if (submitChecklist) {
                            submitChecklist.innerHTML = checklist.map(function(item) {
                                return '<li>' + item + '</li>';
                            }).join('');
                        }
                    } else {
                        // Все условия выполнены
                        submitBtn.disabled = false;
                        if (submitWarning) submitWarning.style.display = 'none';
                    }
                }
                // Делаем функцию доступной глобально для вызова из других IIFE
                window.updateSubmitButtonState = updateSubmitButtonState;

                // Управляет отображением крестика сброса для селекта (класс has-selection)
                function updateSelectHasSelection(selectEl, hasValue) {
                    if (!selectEl) return;
                    if (hasValue) {
                        selectEl.classList.add('has-selection');
                    } else {
                        selectEl.classList.remove('has-selection');
                    }
                }

                // --- Функции перестроения селектов ---

                // Перестраивает селект "Длительность" с заданным количеством периодов
                // selectedPeriods = null — показывает плейсхолдер "выберите период"
                function rebuildDurationSelect(selectedPeriods, maxPeriods) {
                    if (!durationSelect) return;
                    
                    var durationSelectedSpan = durationSelect.querySelector('.selected');
                    var durationOptionsUl = durationSelect.querySelector('ul.options');
                    var placeholder = durationSelect.getAttribute('data-placeholder') || 'Выберите период';
                    
                    if (durationOptionsUl) {
                        durationOptionsUl.innerHTML = '';
                    }
                    
                    if (maxPeriods <= 0) {
                        if (durationSelectedSpan) {
                            durationSelectedSpan.textContent = 'Нет доступных периодов';
                        }
                        durationSelect.classList.add('disabled');
                        updateSelectHasSelection(durationSelect, false);
                        return;
                    }
                    
                    durationSelect.classList.remove('disabled');
                    
                    // Проверяем, есть ли выбранный период в доступном диапазоне
                    var isInRange = selectedPeriods !== null && selectedPeriods >= 1 && selectedPeriods <= maxPeriods;
                    
                    // Если период не выбран — показываем плейсхолдер
                    // Если выбран, но не в диапазоне — показываем номинально
                    if (selectedPeriods === null) {
                        if (durationSelectedSpan) {
                            durationSelectedSpan.textContent = placeholder;
                        }
                    } else if (!isInRange) {
                        // Номинальное отображение периода, которого нет в списке
                        var nominalTotal = minMinutes * selectedPeriods;
                        var nominalHuman = formatDurationHuman(nominalTotal);
                        var nominalLabel = selectedPeriods + ' ' + formatPeriodsLabel(selectedPeriods) + ' — ' + nominalHuman;
                        if (durationSelectedSpan) {
                            durationSelectedSpan.textContent = nominalLabel;
                        }
                    }
                    
                    for (var i = 1; i <= maxPeriods; i++) {
                        var total = minMinutes * i;
                        var human = formatDurationHuman(total);
                        var value = formatDurationHHMM(total);
                        var label = i + ' ' + formatPeriodsLabel(i) + ' — ' + human;
                        
                        var li = document.createElement('li');
                        li.textContent = label;
                        li.setAttribute('data-value', value);
                        li.setAttribute('data-periods', i);
                        
                        if (i === selectedPeriods) {
                            li.classList.add('selected');
                            if (durationSelectedSpan) {
                                durationSelectedSpan.textContent = label;
                            }
                        }
                        
                        // Обработчик: при выборе длительности → обновить списки начала/конца
                        (function (liEl, liLabel, periods) {
                            liEl.addEventListener('click', function (e) {
                                e.stopPropagation();
                                durationOptionsUl.querySelectorAll('li').forEach(function (opt) {
                                    opt.classList.remove('selected');
                                });
                                liEl.classList.add('selected');
                                if (durationSelectedSpan) {
                                    durationSelectedSpan.textContent = liLabel;
                                }
                                durationSelect.classList.remove('open');
                                
                                currentSelectedPeriods = periods;
                                // Крестик сброса показываем при любом выбранном периоде
                                updateSelectHasSelection(durationSelect, true);
                                onDurationChanged();
                            });
                        })(li, label, i);
                        
                        durationOptionsUl.appendChild(li);
                    }
                    
                    // Крестик сброса показываем при любом выбранном периоде
                    updateSelectHasSelection(durationSelect, selectedPeriods !== null);
                }

                // Перестраивает селект "Время начала" с заданным списком слотов
                function rebuildStartTimeSelect(slotsMinutes, selectedMinutes) {
                    if (!startTimeSelect) return;
                    
                    var startSelectedSpan = startTimeSelect.querySelector('.selected');
                    var startOptionsUl = startTimeSelect.querySelector('ul.options');
                    
                    if (startOptionsUl) {
                        startOptionsUl.innerHTML = '';
                    }
                    
                    var placeholder = startTimeSelect.getAttribute('data-placeholder') || 'Выберите время';
                    
                    // hasValue = время установлено (может быть номинальным)
                    var hasValue = selectedMinutes !== null;
                    
                    if (slotsMinutes.length === 0) {
                        if (startSelectedSpan) {
                            // Показываем номинальное время даже если список пуст
                            startSelectedSpan.textContent = hasValue ? formatTimeHHMM(selectedMinutes) : placeholder;
                        }
                        // Список пуст, но селект остаётся активным (можно открыть, просто нет вариантов)
                        startTimeSelect.classList.remove('disabled');
                        // Крестик показываем если есть номинальное значение
                        updateSelectHasSelection(startTimeSelect, hasValue);
                        return;
                    }
                    
                    startTimeSelect.classList.remove('disabled');
                    
                    // hasSelection = время есть в списке доступных
                    var hasSelection = selectedMinutes !== null && slotsMinutes.indexOf(selectedMinutes) !== -1;
                    
                    if (startSelectedSpan) {
                        // Показываем время даже если его нет в списке (номинальное отображение)
                        startSelectedSpan.textContent = hasValue ? formatTimeHHMM(selectedMinutes) : placeholder;
                    }
                    
                    slotsMinutes.forEach(function (slotMinutes) {
                        var slotTimeStr = formatTimeHHMM(slotMinutes);
                        var li = document.createElement('li');
                        li.textContent = slotTimeStr;
                        li.setAttribute('data-value', slotTimeStr);
                        li.setAttribute('data-minutes', slotMinutes);
                        
                        if (slotMinutes === selectedMinutes) {
                            li.classList.add('selected');
                        }
                        
                        // Обработчик: при выборе времени начала → подставить время конца
                        (function (liEl, liTimeStr, liMinutes) {
                            liEl.addEventListener('click', function (e) {
                                e.stopPropagation();
                                startOptionsUl.querySelectorAll('li').forEach(function (opt) {
                                    opt.classList.remove('selected');
                                });
                                liEl.classList.add('selected');
                                if (startSelectedSpan) {
                                    startSelectedSpan.textContent = liTimeStr;
                                }
                                startTimeSelect.classList.remove('open');
                                updateSelectHasSelection(startTimeSelect, true);
                                
                                currentStartTimeMinutes = liMinutes;
                                if (timeField) timeField.value = liTimeStr;
                                
                                // Скрываем предупреждения (выбрано доступное время из списка)
                                var startTimeWarning = document.getElementById('start-time-warning-icon');
                                var endTimeWarning = document.getElementById('end-time-warning-icon');
                                if (startTimeWarning) startTimeWarning.style.display = 'none';
                                if (endTimeWarning) endTimeWarning.style.display = 'none';
                                
                                // Пересчитываем список длительностей для этого времени начала
                                var maxPeriodsForStart = getMaxPeriodsForStartTime(liMinutes, currentRoomId, dateIso);
                                
                                // Обновляем список окончаний "вправо" от времени начала
                                var endTimesForStart = getEndTimesForStartTime(liMinutes);
                                
                                if (currentSelectedPeriods !== null) {
                                    // Длительность выбрана — подставляем окончание по длительности
                                    var newEndTime = liMinutes + (minMinutes * currentSelectedPeriods);
                                    if (currentSelectedPeriods <= maxPeriodsForStart && endTimesForStart.indexOf(newEndTime) !== -1) {
                                        // Длительность помещается — подставляем окончание
                                        currentEndTimeMinutes = newEndTime;
                                        rebuildDurationSelect(currentSelectedPeriods, maxPeriodsForStart);
                                    } else {
                                        // Длительность не помещается — сбрасываем окончание, сохраняем длительность
                                        currentEndTimeMinutes = null;
                                        rebuildDurationSelect(currentSelectedPeriods, maxPeriodsForStart);
                                    }
                                    // Список окончаний фильтруем по длительности
                                    var filteredEndTimes = getAllEndTimesForPeriods(currentSelectedPeriods);
                                    rebuildEndTimeSelect(filteredEndTimes, currentEndTimeMinutes);
                                } else if (currentEndTimeMinutes !== null) {
                                    // Длительность не выбрана, но есть окончание — вычисляем длительность
                                    var periodsBetween = Math.round((currentEndTimeMinutes - liMinutes) / minMinutes);
                                    if (periodsBetween >= 1 && periodsBetween <= maxPeriodsForStart && endTimesForStart.indexOf(currentEndTimeMinutes) !== -1) {
                                        // Время окончания валидно для нового начала
                                        currentSelectedPeriods = periodsBetween;
                                        rebuildDurationSelect(currentSelectedPeriods, maxPeriodsForStart);
                                        rebuildEndTimeSelect(endTimesForStart, currentEndTimeMinutes);
                                    } else if (maxPeriodsForStart === 1) {
                                        // Время окончания не валидно, но единственный вариант длительности — автоподстановка
                                        currentSelectedPeriods = 1;
                                        currentEndTimeMinutes = liMinutes + minMinutes;
                                        rebuildDurationSelect(currentSelectedPeriods, maxPeriodsForStart);
                                        var filteredEndTimes = getAllEndTimesForPeriods(currentSelectedPeriods);
                                        rebuildEndTimeSelect(filteredEndTimes, currentEndTimeMinutes);
                                    } else {
                                        // Время окончания не валидно — сбрасываем его
                                        currentEndTimeMinutes = null;
                                        rebuildDurationSelect(null, maxPeriodsForStart);
                                        rebuildEndTimeSelect(endTimesForStart, currentEndTimeMinutes);
                                    }
                                } else {
                                    // Ничего не выбрано
                                    if (maxPeriodsForStart === 1) {
                                        // Единственный вариант длительности — автоподстановка
                                        currentSelectedPeriods = 1;
                                        currentEndTimeMinutes = liMinutes + minMinutes;
                                        rebuildDurationSelect(currentSelectedPeriods, maxPeriodsForStart);
                                        var filteredEndTimes = getAllEndTimesForPeriods(currentSelectedPeriods);
                                        rebuildEndTimeSelect(filteredEndTimes, currentEndTimeMinutes);
                                    } else {
                                        rebuildDurationSelect(null, maxPeriodsForStart);
                                        rebuildEndTimeSelect(endTimesForStart, currentEndTimeMinutes);
                                    }
                                }
                                // Обновляем фильтрацию преподавателей по новому времени
                                window.currentStartTimeMinutes = currentStartTimeMinutes;
                                window.currentEndTimeMinutes = currentEndTimeMinutes;
                                applyTeacherDirectionFilters();
                                updateSubmitButtonState();
                                
                                // Пересчитываем стоимость брони
                                if (typeof window.calculateAndUpdateBookingCost === 'function') {
                                    window.calculateAndUpdateBookingCost();
                                }
                            });
                        })(li, slotTimeStr, slotMinutes);
                        
                        startOptionsUl.appendChild(li);
                    });
                    
                    // Крестик показываем если есть любое значение (в т.ч. номинальное)
                    updateSelectHasSelection(startTimeSelect, hasValue);
                }

                // Перестраивает селект "Время окончания" с заданным списком времен
                function rebuildEndTimeSelect(endTimesMinutes, selectedMinutes) {
                    if (!endTimeSelect) return;
                    
                    var endTimeSelectedSpan = endTimeSelect.querySelector('.selected');
                    var endTimeOptionsUl = endTimeSelect.querySelector('ul.options');
                    
                    if (endTimeOptionsUl) {
                        endTimeOptionsUl.innerHTML = '';
                    }
                    
                    var placeholder = endTimeSelect.getAttribute('data-placeholder') || 'Выберите время';
                    
                    // hasValue = время установлено (может быть номинальным)
                    var hasValue = selectedMinutes !== null;
                    
                    if (endTimesMinutes.length === 0) {
                        if (endTimeSelectedSpan) {
                            // Показываем номинальное время даже если список пуст
                            endTimeSelectedSpan.textContent = hasValue ? formatTimeHHMM(selectedMinutes) : placeholder;
                        }
                        // Список пуст, но селект остаётся активным (можно открыть, просто нет вариантов)
                        endTimeSelect.classList.remove('disabled');
                        // Крестик показываем если есть номинальное значение
                        updateSelectHasSelection(endTimeSelect, hasValue);
                        return;
                    }
                    
                    endTimeSelect.classList.remove('disabled');
                    
                    // Показываем выбранное время даже если его нет в списке (номинальное значение)
                    var hasSelection = selectedMinutes !== null;
                    var isInList = endTimesMinutes.indexOf(selectedMinutes) !== -1;
                    
                    if (endTimeSelectedSpan) {
                        endTimeSelectedSpan.textContent = hasSelection ? formatTimeHHMM(selectedMinutes) : placeholder;
                    }
                    
                    // Крестик показываем если есть любое значение (в т.ч. номинальное)
                    updateSelectHasSelection(endTimeSelect, hasSelection);
                    
                    endTimesMinutes.forEach(function (endMinutes) {
                        var endTimeStr = formatTimeHHMM(endMinutes);
                        var li = document.createElement('li');
                        li.textContent = endTimeStr;
                        li.setAttribute('data-value', endTimeStr);
                        li.setAttribute('data-minutes', endMinutes);
                        
                        if (endMinutes === selectedMinutes) {
                            li.classList.add('selected');
                        }
                        
                        // Обработчик: при выборе времени окончания → подставить время начала
                        (function (liEl, liTimeStr, liMinutes) {
                            liEl.addEventListener('click', function (e) {
                                e.stopPropagation();
                                endTimeOptionsUl.querySelectorAll('li').forEach(function (opt) {
                                    opt.classList.remove('selected');
                                });
                                liEl.classList.add('selected');
                                if (endTimeSelectedSpan) {
                                    endTimeSelectedSpan.textContent = liTimeStr;
                                }
                                endTimeSelect.classList.remove('open');
                                updateSelectHasSelection(endTimeSelect, true);
                                
                                currentEndTimeMinutes = liMinutes;
                                
                                // Обновляем список начала "влево" от времени окончания
                                var startTimesForEnd = getStartTimesForEndTime(liMinutes);
                                var maxPeriodsForEnd = getMaxPeriodsForEndTime(liMinutes);
                                
                                // Скрываем предупреждения (выбрано доступное время из списка)
                                var startTimeWarning = document.getElementById('start-time-warning-icon');
                                var endTimeWarning = document.getElementById('end-time-warning-icon');
                                if (startTimeWarning) startTimeWarning.style.display = 'none';
                                if (endTimeWarning) endTimeWarning.style.display = 'none';
                                
                                if (currentSelectedPeriods !== null) {
                                    // Длительность выбрана — подставляем начало по длительности
                                    var newStartTime = liMinutes - (minMinutes * currentSelectedPeriods);
                                    if (startTimesForEnd.indexOf(newStartTime) !== -1) {
                                        // Длительность помещается — подставляем начало
                                        currentStartTimeMinutes = newStartTime;
                                        if (timeField) timeField.value = formatTimeHHMM(currentStartTimeMinutes);
                                        rebuildDurationSelect(currentSelectedPeriods, maxPeriodsForEnd);
                                    } else {
                                        // Длительность не помещается — сбрасываем начало, сохраняем длительность
                                        currentStartTimeMinutes = null;
                                        rebuildDurationSelect(currentSelectedPeriods, maxPeriodsForEnd);
                                    }
                                    // Список начала фильтруем по длительности
                                    var filteredStartTimes = getStartTimeSlotsForPeriods(currentSelectedPeriods);
                                    rebuildStartTimeSelect(filteredStartTimes, currentStartTimeMinutes);
                                } else if (currentStartTimeMinutes !== null) {
                                    // Длительность не выбрана, но есть начало — вычисляем длительность
                                    var periodsBetween = Math.round((liMinutes - currentStartTimeMinutes) / minMinutes);
                                    if (periodsBetween >= 1 && periodsBetween <= maxPeriodsForEnd && startTimesForEnd.indexOf(currentStartTimeMinutes) !== -1) {
                                        // Время начала валидно для нового окончания
                                        currentSelectedPeriods = periodsBetween;
                                        rebuildDurationSelect(currentSelectedPeriods, maxPeriodsForEnd);
                                        rebuildStartTimeSelect(startTimesForEnd, currentStartTimeMinutes);
                                    } else if (maxPeriodsForEnd === 1) {
                                        // Время начала не валидно, но единственный вариант длительности — автоподстановка
                                        currentSelectedPeriods = 1;
                                        currentStartTimeMinutes = liMinutes - minMinutes;
                                        if (timeField) timeField.value = formatTimeHHMM(currentStartTimeMinutes);
                                        rebuildDurationSelect(currentSelectedPeriods, maxPeriodsForEnd);
                                        var filteredStartTimes = getStartTimeSlotsForPeriods(currentSelectedPeriods);
                                        rebuildStartTimeSelect(filteredStartTimes, currentStartTimeMinutes);
                                    } else {
                                        // Время начала не валидно — сбрасываем его
                                        currentStartTimeMinutes = null;
                                        rebuildDurationSelect(null, maxPeriodsForEnd);
                                        rebuildStartTimeSelect(startTimesForEnd, currentStartTimeMinutes);
                                    }
                                } else {
                                    // Ничего не выбрано
                                    if (maxPeriodsForEnd === 1) {
                                        // Единственный вариант длительности — автоподстановка
                                        currentSelectedPeriods = 1;
                                        currentStartTimeMinutes = liMinutes - minMinutes;
                                        if (timeField) timeField.value = formatTimeHHMM(currentStartTimeMinutes);
                                        rebuildDurationSelect(currentSelectedPeriods, maxPeriodsForEnd);
                                        var filteredStartTimes = getStartTimeSlotsForPeriods(currentSelectedPeriods);
                                        rebuildStartTimeSelect(filteredStartTimes, currentStartTimeMinutes);
                                    } else {
                                        rebuildDurationSelect(null, maxPeriodsForEnd);
                                        rebuildStartTimeSelect(startTimesForEnd, currentStartTimeMinutes);
                                    }
                                }
                                // Обновляем фильтрацию преподавателей по новому времени
                                window.currentStartTimeMinutes = currentStartTimeMinutes;
                                window.currentEndTimeMinutes = currentEndTimeMinutes;
                                applyTeacherDirectionFilters();
                                updateSubmitButtonState();
                                
                                // Пересчитываем стоимость брони
                                if (typeof window.calculateAndUpdateBookingCost === 'function') {
                                    window.calculateAndUpdateBookingCost();
                                }
                            });
                        })(li, endTimeStr, endMinutes);
                        
                        endTimeOptionsUl.appendChild(li);
                    });
                }

                // --- Синхронизировать отображение времени начала с текущим значением ---
                function syncStartTimeDisplay() {
                    if (!startTimeSelect) return;
                    var startSelectedSpan = startTimeSelect.querySelector('.selected');
                    var startOptionsUl = startTimeSelect.querySelector('ul.options');
                    
                    if (currentStartTimeMinutes === null) {
                        if (startSelectedSpan) {
                            startSelectedSpan.textContent = startTimeSelect.getAttribute('data-placeholder') || 'Выберите время';
                        }
                        updateSelectHasSelection(startTimeSelect, false);
                    } else {
                        if (startSelectedSpan) {
                            startSelectedSpan.textContent = formatTimeHHMM(currentStartTimeMinutes);
                        }
                        updateSelectHasSelection(startTimeSelect, true);
                    }
                    
                    if (startOptionsUl) {
                        startOptionsUl.querySelectorAll('li').forEach(function (li) {
                            var mins = parseInt(li.getAttribute('data-minutes'), 10);
                            if (mins === currentStartTimeMinutes) {
                                li.classList.add('selected');
                            } else {
                                li.classList.remove('selected');
                            }
                        });
                    }
                }

                // --- Обработчики событий изменения селектов ---

                // Обработчик изменения длительности: обновляет списки начала/окончания
                function onDurationChanged() {
                    var durationMinutes = minMinutes * currentSelectedPeriods;
                    
                    // Скрываем предупреждения (выбрана доступная длительность из списка)
                    var startTimeWarning = document.getElementById('start-time-warning-icon');
                    var endTimeWarning = document.getElementById('end-time-warning-icon');
                    if (startTimeWarning) startTimeWarning.style.display = 'none';
                    if (endTimeWarning) endTimeWarning.style.display = 'none';
                    
                    // Списки начала/окончания фильтруются по выбранной длительности
                    var filteredStartSlots = getStartTimeSlotsForPeriods(currentSelectedPeriods);
                    var filteredEndTimes = getAllEndTimesForPeriods(currentSelectedPeriods);
                    
                    if (currentStartTimeMinutes !== null) {
                        // Есть время начала — подставляем окончание
                        var maxPeriodsForStart = getMaxPeriodsForStartTime(currentStartTimeMinutes, currentRoomId, dateIso);
                        if (currentSelectedPeriods <= maxPeriodsForStart) {
                            currentEndTimeMinutes = currentStartTimeMinutes + durationMinutes;
                        } else {
                            // Период недоступен для этого начала — сбрасываем оба
                            currentStartTimeMinutes = null;
                            currentEndTimeMinutes = null;
                        }
                        
                        rebuildStartTimeSelect(filteredStartSlots, currentStartTimeMinutes);
                        rebuildEndTimeSelect(filteredEndTimes, currentEndTimeMinutes);
                    } else if (currentEndTimeMinutes !== null) {
                        // Есть время окончания — подставляем начало
                        var potentialStart = currentEndTimeMinutes - durationMinutes;
                        
                        if (filteredStartSlots.indexOf(potentialStart) !== -1) {
                            currentStartTimeMinutes = potentialStart;
                            if (timeField) timeField.value = formatTimeHHMM(currentStartTimeMinutes);
                        } else {
                            // Время начала для этой длительности недоступно — сбрасываем время окончания
                            currentEndTimeMinutes = null;
                        }
                        
                        rebuildStartTimeSelect(filteredStartSlots, currentStartTimeMinutes);
                        rebuildEndTimeSelect(filteredEndTimes, currentEndTimeMinutes);
                    } else {
                        // Ничего не выбрано — списки фильтруются по длительности
                        rebuildStartTimeSelect(filteredStartSlots, null);
                        rebuildEndTimeSelect(filteredEndTimes, null);
                    }
                    
                    // Обновляем фильтрацию преподавателей по новому времени
                    window.currentStartTimeMinutes = currentStartTimeMinutes;
                    window.currentEndTimeMinutes = currentEndTimeMinutes;
                    applyTeacherDirectionFilters();
                    updateSubmitButtonState();
                    
                    // Пересчитываем стоимость брони
                    calculateAndUpdateBookingCost();
                }

                // --- Функции сброса селектов (по нажатию крестика) ---

                // Сброс селекта "Время начала": сохраняет время окончания если есть
                function resetStartTime() {
                    currentStartTimeMinutes = null;
                    // НЕ сбрасываем время окончания
                    
                    // Скрываем предупреждение о недоступном слоте
                    var startTimeWarning = document.getElementById('start-time-warning-icon');
                    if (startTimeWarning) startTimeWarning.style.display = 'none';
                    
                    if (currentEndTimeMinutes !== null) {
                        // Есть время окончания — список начала "влево", сбрасываем длительность
                        var startTimesForEnd = getStartTimesForEndTime(currentEndTimeMinutes);
                        var maxPeriodsForEnd = getMaxPeriodsForEndTime(currentEndTimeMinutes);
                        currentSelectedPeriods = null;
                        rebuildDurationSelect(null, maxPeriodsForEnd);
                        rebuildStartTimeSelect(startTimesForEnd, null);
                        rebuildEndTimeSelect(getAllEndTimesForPeriods(1), currentEndTimeMinutes);
                    } else {
                        // Оба значения сброшены — глобальные списки
                        currentSelectedPeriods = null;
                        rebuildDurationSelect(null, getGlobalMaxPeriods());
                        rebuildStartTimeSelect(getStartTimeSlotsForPeriods(1), null);
                        rebuildEndTimeSelect(getAllEndTimesForPeriods(1), null);
                    }
                    
                    // Обновляем фильтрацию преподавателей
                    window.currentStartTimeMinutes = currentStartTimeMinutes;
                    window.currentEndTimeMinutes = currentEndTimeMinutes;
                    applyTeacherDirectionFilters();
                    updateSubmitButtonState();
                    
                    // Пересчитываем стоимость брони
                    if (typeof window.calculateAndUpdateBookingCost === 'function') {
                        window.calculateAndUpdateBookingCost();
                    }
                }

                // Сброс селекта "Время окончания": сохраняет время начала если есть
                function resetEndTime() {
                    currentEndTimeMinutes = null;
                    // НЕ сбрасываем время начала
                    
                    // Скрываем предупреждение о недоступном времени окончания
                    var endTimeWarning = document.getElementById('end-time-warning-icon');
                    if (endTimeWarning) endTimeWarning.style.display = 'none';
                    
                    if (currentStartTimeMinutes !== null) {
                        // Есть время начала — список окончаний "вправо", сбрасываем длительность
                        var maxPeriodsForStart = getMaxPeriodsForStartTime(currentStartTimeMinutes, currentRoomId, dateIso);
                        var endTimesForStart = getEndTimesForStartTime(currentStartTimeMinutes);
                        currentSelectedPeriods = null;
                        rebuildDurationSelect(null, maxPeriodsForStart);
                        rebuildStartTimeSelect(getStartTimeSlotsForPeriods(1), currentStartTimeMinutes);
                        rebuildEndTimeSelect(endTimesForStart, null);
                    } else {
                        // Оба значения сброшены — глобальные списки
                        currentSelectedPeriods = null;
                        rebuildDurationSelect(null, getGlobalMaxPeriods());
                        rebuildStartTimeSelect(getStartTimeSlotsForPeriods(1), null);
                        rebuildEndTimeSelect(getAllEndTimesForPeriods(1), null);
                    }
                    
                    // Обновляем фильтрацию преподавателей
                    window.currentStartTimeMinutes = currentStartTimeMinutes;
                    window.currentEndTimeMinutes = currentEndTimeMinutes;
                    applyTeacherDirectionFilters();
                    updateSubmitButtonState();
                    
                    // Пересчитываем стоимость брони
                    if (typeof window.calculateAndUpdateBookingCost === 'function') {
                        window.calculateAndUpdateBookingCost();
                    }
                }

                // Сброс селекта "Длительность": сбрасывает связанные значения
                function resetDuration() {
                    // Сбрасываем на плейсхолдер "выберите период"
                    currentSelectedPeriods = null;
                    
                    // Скрываем предупреждения (сбрасываем номинальные значения)
                    var startTimeWarning = document.getElementById('start-time-warning-icon');
                    var endTimeWarning = document.getElementById('end-time-warning-icon');
                    if (startTimeWarning) startTimeWarning.style.display = 'none';
                    if (endTimeWarning) endTimeWarning.style.display = 'none';
                    
                    if (currentStartTimeMinutes !== null) {
                        // Есть время начала — список окончаний "вправо", сбрасываем окончание
                        var maxPeriodsForStart = getMaxPeriodsForStartTime(currentStartTimeMinutes, currentRoomId, dateIso);
                        var endTimesForStart = getEndTimesForStartTime(currentStartTimeMinutes);
                        currentEndTimeMinutes = null;
                        rebuildDurationSelect(null, maxPeriodsForStart);
                        rebuildStartTimeSelect(getStartTimeSlotsForPeriods(1), currentStartTimeMinutes);
                        rebuildEndTimeSelect(endTimesForStart, null);
                    } else if (currentEndTimeMinutes !== null) {
                        // Есть время окончания — список начала "влево", сбрасываем начало
                        var startTimesForEnd = getStartTimesForEndTime(currentEndTimeMinutes);
                        var maxPeriodsForEnd = getMaxPeriodsForEndTime(currentEndTimeMinutes);
                        currentStartTimeMinutes = null;
                        rebuildDurationSelect(null, maxPeriodsForEnd);
                        rebuildStartTimeSelect(startTimesForEnd, null);
                        rebuildEndTimeSelect(getAllEndTimesForPeriods(1), currentEndTimeMinutes);
                    } else {
                        // Оба значения не установлены — глобальные списки
                        rebuildDurationSelect(null, getGlobalMaxPeriods());
                        rebuildStartTimeSelect(getStartTimeSlotsForPeriods(1), null);
                        rebuildEndTimeSelect(getAllEndTimesForPeriods(1), null);
                    }
                    
                    // Обновляем фильтрацию преподавателей
                    window.currentStartTimeMinutes = currentStartTimeMinutes;
                    window.currentEndTimeMinutes = currentEndTimeMinutes;
                    applyTeacherDirectionFilters();
                    updateSubmitButtonState();
                    
                    // Пересчитываем стоимость брони (длительность сброшена — стоимость 0)
                    calculateAndUpdateBookingCost();
                }

                // --- Привязка обработчиков сброса (крестиков) ---
                function bindClearButtons() {
                    var startClearBtn = startTimeSelect ? startTimeSelect.querySelector('.custom-select-clear') : null;
                    var endClearBtn = endTimeSelect ? endTimeSelect.querySelector('.custom-select-clear') : null;
                    var durationClearBtn = durationSelect ? durationSelect.querySelector('.custom-select-clear') : null;
                    
                    if (startClearBtn) {
                        startClearBtn.addEventListener('click', function (e) {
                            e.preventDefault();
                            e.stopPropagation();
                            resetStartTime();
                            startTimeSelect.classList.remove('open');
                        });
                    }
                    
                    if (endClearBtn) {
                        endClearBtn.addEventListener('click', function (e) {
                            e.preventDefault();
                            e.stopPropagation();
                            resetEndTime();
                            endTimeSelect.classList.remove('open');
                        });
                    }
                    
                    if (durationClearBtn) {
                        durationClearBtn.addEventListener('click', function (e) {
                            e.preventDefault();
                            e.stopPropagation();
                            resetDuration();
                            durationSelect.classList.remove('open');
                        });
                    }
                }

                // =====================================================
                // МОДУЛЬ КАЛЕНДАРЯ (DATEPICKER)
                // =====================================================
                
                var datepickerTrigger = document.getElementById('datepicker-trigger');
                var datepickerPopup = document.getElementById('datepicker-popup');
                var datepickerDisplay = document.getElementById('datepicker-display');
                var datepickerGrid = document.getElementById('datepicker-grid');
                var datepickerMonthSelect = document.getElementById('datepicker-month');
                var datepickerYearSelect = document.getElementById('datepicker-year');
                var datepickerPrevBtn = document.getElementById('datepicker-prev');
                var datepickerNextBtn = document.getElementById('datepicker-next');
                var datepickerTodayBtn = document.getElementById('datepicker-today');
                var datepickerInput = document.getElementById('modal-create-date');
                
                // Текущий отображаемый месяц в календаре
                var datepickerCurrentMonth = new Date(dateIso);
                // Выбранная дата
                var datepickerSelectedDate = new Date(dateIso);
                
                var monthNames = ['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь',
                                  'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'];
                
                // Форматирование даты для отображения (например: "13 декабря 2025")
                function formatDateDisplay(date) {
                    var day = date.getDate();
                    var monthIdx = date.getMonth();
                    var year = date.getFullYear();
                    var monthNamesGenitive = ['января', 'февраля', 'марта', 'апреля', 'мая', 'июня',
                                              'июля', 'августа', 'сентября', 'октября', 'ноября', 'декабря'];
                    return day + ' ' + monthNamesGenitive[monthIdx] + ' ' + year;
                }
                
                // Форматирование даты в ISO (YYYY-MM-DD)
                function formatDateIso(date) {
                    var y = date.getFullYear();
                    var m = String(date.getMonth() + 1).padStart(2, '0');
                    var d = String(date.getDate()).padStart(2, '0');
                    return y + '-' + m + '-' + d;
                }
                
                // Заполнение select месяцев
                function populateMonthSelect() {
                    datepickerMonthSelect.innerHTML = '';
                    for (var i = 0; i < 12; i++) {
                        var opt = document.createElement('option');
                        opt.value = i;
                        opt.textContent = monthNames[i];
                        if (i === datepickerCurrentMonth.getMonth()) {
                            opt.selected = true;
                        }
                        datepickerMonthSelect.appendChild(opt);
                    }
                }
                
                // Заполнение select годов (текущий год ±5)
                function populateYearSelect() {
                    datepickerYearSelect.innerHTML = '';
                    var currentYear = new Date().getFullYear();
                    for (var y = currentYear - 2; y <= currentYear + 3; y++) {
                        var opt = document.createElement('option');
                        opt.value = y;
                        opt.textContent = y;
                        if (y === datepickerCurrentMonth.getFullYear()) {
                            opt.selected = true;
                        }
                        datepickerYearSelect.appendChild(opt);
                    }
                }
                
                // Построение сетки дней
                function buildDatepickerGrid() {
                    datepickerGrid.innerHTML = '';
                    
                    var year = datepickerCurrentMonth.getFullYear();
                    var month = datepickerCurrentMonth.getMonth();
                    
                    // Первый день месяца
                    var firstDay = new Date(year, month, 1);
                    // День недели первого числа (0=Вс, переводим в Пн=0)
                    var startDayOfWeek = (firstDay.getDay() + 6) % 7;
                    
                    // Последний день месяца
                    var lastDay = new Date(year, month + 1, 0);
                    var daysInMonth = lastDay.getDate();
                    
                    // Предыдущий месяц — для заполнения пустых ячеек
                    var prevMonthLastDay = new Date(year, month, 0).getDate();
                    
                    var today = new Date();
                    today.setHours(0, 0, 0, 0);
                    
                    // Дни предыдущего месяца
                    for (var i = startDayOfWeek - 1; i >= 0; i--) {
                        var dayNum = prevMonthLastDay - i;
                        var cell = document.createElement('div');
                        cell.className = 'modal-datepicker__day modal-datepicker__day--outside';
                        cell.textContent = dayNum;
                        datepickerGrid.appendChild(cell);
                    }
                    
                    // Дни текущего месяца
                    for (var d = 1; d <= daysInMonth; d++) {
                        var cell = document.createElement('div');
                        cell.className = 'modal-datepicker__day';
                        cell.textContent = d;
                        
                        var cellDate = new Date(year, month, d);
                        cellDate.setHours(0, 0, 0, 0);
                        
                        // Сегодня
                        if (cellDate.getTime() === today.getTime()) {
                            cell.classList.add('modal-datepicker__day--today');
                        }
                        
                        // Выбранная дата
                        if (datepickerSelectedDate &&
                            cellDate.getFullYear() === datepickerSelectedDate.getFullYear() &&
                            cellDate.getMonth() === datepickerSelectedDate.getMonth() &&
                            cellDate.getDate() === datepickerSelectedDate.getDate()) {
                            cell.classList.add('modal-datepicker__day--selected');
                        }
                        
                        // Обработчик клика
                        (function(dayDate) {
                            cell.addEventListener('click', function() {
                                onDateSelected(dayDate);
                            });
                        })(cellDate);
                        
                        datepickerGrid.appendChild(cell);
                    }
                    
                    // Дни следующего месяца (заполнение до конца сетки)
                    var totalCells = datepickerGrid.children.length;
                    var remainingCells = (7 - (totalCells % 7)) % 7;
                    for (var n = 1; n <= remainingCells; n++) {
                        var cell = document.createElement('div');
                        cell.className = 'modal-datepicker__day modal-datepicker__day--outside';
                        cell.textContent = n;
                        datepickerGrid.appendChild(cell);
                    }
                }
                
                // Обновление отображения календаря
                function renderDatepicker() {
                    populateMonthSelect();
                    populateYearSelect();
                    buildDatepickerGrid();
                }
                
                // Обработчик выбора даты
                function onDateSelected(newDate) {
                    datepickerSelectedDate = newDate;
                    var newDateIso = formatDateIso(newDate);
                    
                    // Обновляем отображение и скрытый input (получаем по ID т.к. элемент мог быть клонирован)
                    var displayEl = document.getElementById('datepicker-display');
                    if (displayEl) displayEl.textContent = formatDateDisplay(newDate);
                    datepickerInput.value = newDateIso;
                    
                    // Закрываем попап
                    datepickerPopup.classList.remove('open');
                    
                    // --- Пересчёт списков времени для новой даты ---
                    dateIso = newDateIso;
                    if (dateField) dateField.value = dateIso;
                    
                    // Загружаем все брони комнаты на новую дату через AJAX и пересчитываем
                    loadRoomBookingsForDate(currentRoomId, dateIso, function() {
                        // Элементы предупреждений
                        var startTimeWarning = document.getElementById('start-time-warning-icon');
                        var endTimeWarning = document.getElementById('end-time-warning-icon');
                        
                        // Скрываем предупреждения по умолчанию
                        if (startTimeWarning) startTimeWarning.style.display = 'none';
                        if (endTimeWarning) endTimeWarning.style.display = 'none';
                        
                        // Пересчитываем списки для нового дня
                        var newAllSlots = getStartTimeSlotsForPeriods(1);
                        var newGlobalMaxPeriods = getGlobalMaxPeriods();
                        
                        // Флаги валидности времени
                        var startTimeValid = true;
                        var endTimeValid = true;
                        
                        // Проверяем доступность текущего времени начала
                        if (currentStartTimeMinutes !== null) {
                            var newMaxPeriodsForStart = getMaxPeriodsForStartTime(currentStartTimeMinutes, currentRoomId, dateIso);
                            if (newMaxPeriodsForStart < 1) {
                                // Время начала недоступно — показываем номинально с предупреждением
                                startTimeValid = false;
                                if (startTimeWarning) startTimeWarning.style.display = 'inline-block';
                            }
                        }
                        
                        // Проверяем доступность текущего времени окончания
                        if (currentEndTimeMinutes !== null && currentStartTimeMinutes !== null) {
                            if (!startTimeValid) {
                                // Если время начала невалидно — время окончания тоже невалидно
                                endTimeValid = false;
                                if (endTimeWarning) endTimeWarning.style.display = 'inline-block';
                            } else {
                                var newMaxPeriodsForStart = getMaxPeriodsForStartTime(currentStartTimeMinutes, currentRoomId, dateIso);
                                var maxEndTime = currentStartTimeMinutes + (minMinutes * newMaxPeriodsForStart);
                                if (currentEndTimeMinutes > maxEndTime) {
                                    // Время окончания недоступно — показываем номинально с предупреждением
                                    endTimeValid = false;
                                    if (endTimeWarning) endTimeWarning.style.display = 'inline-block';
                                }
                            }
                        }
                        
                        // Формируем списки в зависимости от состояния
                        if (currentStartTimeMinutes !== null && startTimeValid) {
                            var newMaxPeriodsForStart = getMaxPeriodsForStartTime(currentStartTimeMinutes, currentRoomId, dateIso);
                            
                            // Автоподстановка при единственном периоде
                            if (newMaxPeriodsForStart === 1 && currentSelectedPeriods === null && currentEndTimeMinutes === null) {
                                currentSelectedPeriods = 1;
                                currentEndTimeMinutes = currentStartTimeMinutes + minMinutes;
                                endTimeValid = true;
                                if (endTimeWarning) endTimeWarning.style.display = 'none';
                            }
                            
                            // Проверяем, помещается ли выбранная длительность — если нет, делаем номинальной с предупреждением
                            if (currentSelectedPeriods !== null && currentSelectedPeriods > newMaxPeriodsForStart) {
                                // Длительность и окончание не помещаются — показываем предупреждение на окончании
                                endTimeValid = false;
                                if (endTimeWarning) endTimeWarning.style.display = 'inline-block';
                            }
                            
                            // Строим списки
                            if (currentSelectedPeriods !== null) {
                                // Длительность выбрана — фильтруем списки по ней
                                var filteredStartSlots = getStartTimeSlotsForPeriods(currentSelectedPeriods);
                                var filteredEndTimes = getAllEndTimesForPeriods(currentSelectedPeriods);
                                rebuildStartTimeSelect(filteredStartSlots, currentStartTimeMinutes);
                                rebuildEndTimeSelect(filteredEndTimes, currentEndTimeMinutes);
                            } else {
                                var newEndTimes = getEndTimesForStartTime(currentStartTimeMinutes);
                                rebuildStartTimeSelect(newAllSlots, currentStartTimeMinutes);
                                rebuildEndTimeSelect(newEndTimes, currentEndTimeMinutes);
                            }
                            
                            rebuildDurationSelect(currentSelectedPeriods, newMaxPeriodsForStart);
                        } else {
                            // Время начала не выбрано или невалидно — глобальные списки, но сохраняем номинальные значения
                            if (currentSelectedPeriods !== null) {
                                var filteredSlots = getStartTimeSlotsForPeriods(currentSelectedPeriods);
                                var filteredEndTimes = getAllEndTimesForPeriods(currentSelectedPeriods);
                                rebuildStartTimeSelect(filteredSlots, currentStartTimeMinutes);
                                rebuildEndTimeSelect(filteredEndTimes, currentEndTimeMinutes);
                            } else {
                                rebuildStartTimeSelect(newAllSlots, currentStartTimeMinutes);
                                rebuildEndTimeSelect(getAllEndTimesForPeriods(1), currentEndTimeMinutes);
                            }
                            rebuildDurationSelect(currentSelectedPeriods, newGlobalMaxPeriods);
                        }
                        
                        // Синхронизируем глобальные переменные и загружаем занятых специалистов
                        window.currentStartTimeMinutes = currentStartTimeMinutes;
                        window.currentEndTimeMinutes = currentEndTimeMinutes;
                        loadBusySpecialistsForDate(dateIso, function() {
                            // applyTeacherDirectionFilters вызовет updateSubmitButtonState внутри
                            applyTeacherDirectionFilters();
                        });
                    });
                }
                
                // Обработчики событий календаря (удаляем старые через клонирование, чтобы не накапливались)
                function replaceWithClone(el) {
                    if (!el) return null;
                    var clone = el.cloneNode(true);
                    el.parentNode.replaceChild(clone, el);
                    return clone;
                }
                
                // Обновляем ссылки на элементы после клонирования
                datepickerTrigger = replaceWithClone(datepickerTrigger);
                // После клонирования trigger нужно обновить ссылку на display внутри него
                datepickerDisplay = document.getElementById('datepicker-display');
                datepickerPrevBtn = replaceWithClone(datepickerPrevBtn);
                datepickerNextBtn = replaceWithClone(datepickerNextBtn);
                datepickerMonthSelect = replaceWithClone(datepickerMonthSelect);
                datepickerYearSelect = replaceWithClone(datepickerYearSelect);
                datepickerTodayBtn = replaceWithClone(datepickerTodayBtn);
                
                if (datepickerTrigger) {
                    datepickerTrigger.addEventListener('click', function(e) {
                        e.stopPropagation();
                        // Закрываем другие открытые селекты
                        var modal = document.getElementById('createBookingModal');
                        if (modal) {
                            modal.querySelectorAll('.custom-select.open').forEach(function(s) {
                                s.classList.remove('open');
                            });
                        }
                        datepickerPopup.classList.toggle('open');
                        if (datepickerPopup.classList.contains('open')) {
                            // Показываем месяц выбранной даты
                            datepickerCurrentMonth = new Date(datepickerSelectedDate.getFullYear(), datepickerSelectedDate.getMonth(), 1);
                            renderDatepicker();
                        }
                    });
                }
                
                if (datepickerPrevBtn) {
                    datepickerPrevBtn.addEventListener('click', function(e) {
                        e.stopPropagation();
                        datepickerCurrentMonth.setMonth(datepickerCurrentMonth.getMonth() - 1);
                        renderDatepicker();
                    });
                }
                
                if (datepickerNextBtn) {
                    datepickerNextBtn.addEventListener('click', function(e) {
                        e.stopPropagation();
                        datepickerCurrentMonth.setMonth(datepickerCurrentMonth.getMonth() + 1);
                        renderDatepicker();
                    });
                }
                
                if (datepickerMonthSelect) {
                    datepickerMonthSelect.addEventListener('change', function() {
                        datepickerCurrentMonth.setMonth(parseInt(this.value, 10));
                        renderDatepicker();
                    });
                }
                
                if (datepickerYearSelect) {
                    datepickerYearSelect.addEventListener('change', function() {
                        datepickerCurrentMonth.setFullYear(parseInt(this.value, 10));
                        renderDatepicker();
                    });
                }
                
                if (datepickerTodayBtn) {
                    datepickerTodayBtn.addEventListener('click', function(e) {
                        e.stopPropagation();
                        var today = new Date();
                        onDateSelected(today);
                    });
                }
                
                // Закрытие попапа по клику вне (используем глобальный флаг чтобы не накапливать обработчики)
                if (!window._datepickerClickHandlerAdded) {
                    window._datepickerClickHandlerAdded = true;
                    document.addEventListener('click', function(e) {
                        var popup = document.getElementById('datepicker-popup');
                        var trigger = document.getElementById('datepicker-trigger');
                        if (popup && popup.classList.contains('open')) {
                            if (!popup.contains(e.target) && trigger && !trigger.contains(e.target)) {
                                popup.classList.remove('open');
                            }
                        }
                    });
                }
                
                // Инициализация отображения даты (получаем по ID для надёжности после клонирования)
                var displayElInit = document.getElementById('datepicker-display');
                if (displayElInit) displayElInit.textContent = formatDateDisplay(datepickerSelectedDate);
                datepickerInput.value = dateIso;

                // --- Первоначальная инициализация ---
                bindClearButtons();
                
                // Загружаем все брони комнаты на дату через AJAX (без фильтра по сценарию)
                // и только после этого инициализируем селекты
                loadRoomBookingsForDate(currentRoomId, dateIso, function() {
                    // Вычисляем максимально возможное количество периодов
                    var allStartSlots = getStartTimeSlotsForPeriods(1);
                    var globalMaxPeriods = getGlobalMaxPeriods();
                    
                    // Проверяем доступность нажатого слота
                    var clickedSlotMaxPeriods = getMaxPeriodsForStartTime(clickedSlotMinutes, currentRoomId, dateIso);
                    var clickedSlotAvailable = clickedSlotMaxPeriods >= 1;
                    
                    // Элемент предупреждения о недоступном слоте
                    var startTimeWarning = document.getElementById('start-time-warning-icon');
                    
                    // Начальное состояние: время начала установлено, время окончания и период НЕ выбраны
                    currentSelectedPeriods = null;
                    currentEndTimeMinutes = null;
                    
                    if (clickedSlotAvailable) {
                        // Слот доступен — устанавливаем время начала
                        currentStartTimeMinutes = clickedSlotMinutes;
                        if (startTimeWarning) startTimeWarning.style.display = 'none';
                        
                        // Если единственный вариант длительности — автоподстановка
                        if (clickedSlotMaxPeriods === 1) {
                            currentSelectedPeriods = 1;
                            currentEndTimeMinutes = clickedSlotMinutes + minMinutes;
                        }
                    } else {
                        // Слот недоступен — показываем время номинально, но не в списке
                        currentStartTimeMinutes = clickedSlotMinutes;
                        if (startTimeWarning) startTimeWarning.style.display = 'inline-block';
                    }
                    
                    // Инициализируем все селекты
                    var maxPeriodsForStart = clickedSlotAvailable ? clickedSlotMaxPeriods : globalMaxPeriods;
                    rebuildDurationSelect(currentSelectedPeriods, maxPeriodsForStart);
                    rebuildStartTimeSelect(allStartSlots, currentStartTimeMinutes);
                    
                    // Время окончания: список "вправо" от времени начала (если доступно)
                    var endTimes;
                    if (currentSelectedPeriods !== null) {
                        // Длительность выбрана — фильтруем по длительности
                        endTimes = getAllEndTimesForPeriods(currentSelectedPeriods);
                    } else if (clickedSlotAvailable) {
                        endTimes = getEndTimesForStartTime(clickedSlotMinutes);
                    } else {
                        endTimes = getAllEndTimesForPeriods(1);
                    }
                    rebuildEndTimeSelect(endTimes, currentEndTimeMinutes);
                    
                    // Синхронизируем глобальные переменные и загружаем занятых специалистов
                    window.currentStartTimeMinutes = currentStartTimeMinutes;
                    window.currentEndTimeMinutes = currentEndTimeMinutes;
                    loadBusySpecialistsForDate(dateIso, function() {
                        // applyTeacherDirectionFilters вызовет updateSubmitButtonState внутри
                        applyTeacherDirectionFilters();
                    });
                });

                if (dateField) dateField.value = dateIso;
                if (timeField) timeField.value = timeHm;
            }
        }
    }

    // Счётчик символов для поля комментария
    document.addEventListener('DOMContentLoaded', function () {
        var textarea = document.getElementById('bookingComment');
        var counter = document.getElementById('bookingCommentCounter');
        var maxLength = 1000;

        if (!textarea || !counter) {
            return;
        }

        function updateCounter() {
            var val = textarea.value || '';

            if (val.length > maxLength) {
                textarea.value = val.slice(0, maxLength);
                val = textarea.value;
            }

            counter.textContent = val.length + '/' + maxLength;

            if (val.length >= maxLength) {
                counter.style.color = '#FF0000'; // красный
            } else if (val.length >= 900) {
                counter.style.color = '#FFA500'; // оранжевый
            } else {
                counter.style.color = '#818EA2'; // обычный
            }
        }

        textarea.addEventListener('input', updateCounter);
        updateCounter();
    });

    // Кастомные селекты только внутри этой модалки
    (function () {
        var modalElement = document.getElementById('createBookingModal');
        if (!modalElement) {
            return;
        }

        var teacherDirectionLastChanged = null;

        // --------------------------
        // Вспомогательные функции
        // --------------------------

        function getSelectedValue(selectEl) {
            var selectedLi = selectEl.querySelector('ul.options li.selected');
            return selectedLi ? (selectedLi.getAttribute('data-value') || '') : '';
        }

        function syncClearableSelectState(selectEl) {
            if (!selectEl || !selectEl.classList.contains('custom-select--clearable')) {
                return;
            }

            var hasValue = Boolean(getSelectedValue(selectEl));
            if (hasValue) {
                selectEl.classList.add('has-selection');
            } else {
                selectEl.classList.remove('has-selection');
            }
        }

        function resetSelect(selectEl) {
            var selectedSpan = selectEl.querySelector('.selected');
            var placeholder = selectEl.getAttribute('data-placeholder') || (selectedSpan ? selectedSpan.textContent : '');
            var options = selectEl.querySelectorAll('ul.options li');

            options.forEach(function (li) {
                li.classList.remove('selected');
            });

            if (selectedSpan) {
                selectedSpan.textContent = placeholder;
            }

            syncClearableSelectState(selectEl);
        }

        function resetTeacherDirectionUI() {
            var teacherSelect = modalElement.querySelector('#teacher');
            var directionSelect = modalElement.querySelector('#field-direction');
            if (!teacherSelect || !directionSelect) {
                return;
            }

            resetSelect(teacherSelect);
            resetSelect(directionSelect);

            teacherSelect.querySelectorAll('ul.options li').forEach(function (li) {
                li.style.display = '';
            });
            directionSelect.querySelectorAll('ul.options li').forEach(function (li) {
                li.style.display = '';
            });
        }

        function applyTeacherDirectionFilters() {
            var teacherSelect = modalElement.querySelector('#teacher');
            var directionSelect = modalElement.querySelector('#field-direction');
            if (!teacherSelect || !directionSelect) {
                return;
            }

            var selectedTeacherId = getSelectedValue(teacherSelect);
            var selectedDirectionId = getSelectedValue(directionSelect);

            var teacherLis = teacherSelect.querySelectorAll('ul.options li');
            var directionLis = directionSelect.querySelectorAll('ul.options li');
            
            // Получаем текущее время начала и окончания для проверки доступности (из глобальных переменных)
            var startMinutes = window.currentStartTimeMinutes;
            var endMinutes = window.currentEndTimeMinutes;
            var teacherWarning = document.getElementById('teacher-warning-icon');
            
            // Вычисляем время для проверки доступности
            var checkStartMinutes = startMinutes;
            var checkEndMinutes = endMinutes;
            if (startMinutes !== null && endMinutes === null) {
                checkEndMinutes = startMinutes + 30;
            } else if (startMinutes === null && endMinutes !== null) {
                checkStartMinutes = endMinutes - 30;
            }

            // 1) Сначала определяем доступных специалистов
            var availableTeacherIds = [];
            var availableDirectionIds = new Set();
            
            teacherLis.forEach(function (li) {
                var teacherId = parseInt(li.getAttribute('data-value'), 10);
                var dirsRaw = li.getAttribute('data-directions') || '';
                var dirs = dirsRaw ? dirsRaw.split(',').map(function (v) { return v.trim(); }).filter(Boolean) : [];
                
                // Проверяем доступность по времени
                var timeAvailable = true;
                if (checkStartMinutes !== null && checkEndMinutes !== null) {
                    timeAvailable = !window.isSpecialistBusy(teacherId, checkStartMinutes, checkEndMinutes);
                }
                
                if (timeAvailable && !isNaN(teacherId)) {
                    availableTeacherIds.push(teacherId);
                    // Собираем направления доступных специалистов
                    dirs.forEach(function(dirId) {
                        availableDirectionIds.add(dirId);
                    });
                }
            });

            // 2) Проверка на конфликт: если оба выбраны, но не совместимы — сбрасываем противоположный
            if (selectedTeacherId && selectedDirectionId) {
                var selectedTeacherLi = teacherSelect.querySelector('ul.options li.selected');
                var teacherDirectionsRaw = selectedTeacherLi ? (selectedTeacherLi.getAttribute('data-directions') || '') : '';
                var teacherDirections = teacherDirectionsRaw ? teacherDirectionsRaw.split(',').map(function (v) { return v.trim(); }).filter(Boolean) : [];

                if (teacherDirections.indexOf(String(selectedDirectionId)) === -1) {
                    if (teacherDirectionLastChanged === 'field-direction') {
                        resetSelect(teacherSelect);
                        selectedTeacherId = '';
                    } else {
                        resetSelect(directionSelect);
                        selectedDirectionId = '';
                    }
                }
            }

            // 3) Фильтрация направлений
            var visibleDirectionCount = 0;
            var lastVisibleDirectionLi = null;
            
            if (selectedTeacherId) {
                // Если выбран преподаватель — показываем только его направления
                var teacherLi = teacherSelect.querySelector('ul.options li.selected');
                var dirsRaw = teacherLi ? (teacherLi.getAttribute('data-directions') || '') : '';
                var allowedDirs = dirsRaw ? dirsRaw.split(',').map(function (v) { return v.trim(); }).filter(Boolean) : [];

                directionLis.forEach(function (li) {
                    var dirId = li.getAttribute('data-value') || '';
                    var isVisible = allowedDirs.indexOf(String(dirId)) !== -1;
                    li.style.display = isVisible ? '' : 'none';
                    if (isVisible) {
                        visibleDirectionCount++;
                        lastVisibleDirectionLi = li;
                    }
                });
            } else {
                // Если преподаватель не выбран — показываем только направления доступных специалистов
                directionLis.forEach(function (li) {
                    var dirId = li.getAttribute('data-value') || '';
                    var isVisible = availableDirectionIds.has(dirId);
                    li.style.display = isVisible ? '' : 'none';
                    if (isVisible) {
                        visibleDirectionCount++;
                        lastVisibleDirectionLi = li;
                    }
                });
            }
            
            // 4) Обновляем состояние селекта направлений
            var dirSelectedSpan = directionSelect.querySelector('span.selected');
            if (visibleDirectionCount === 0) {
                // Нет доступных направлений
                directionSelect.classList.add('disabled');
                if (dirSelectedSpan) dirSelectedSpan.textContent = 'Нет доступных направлений';
            } else {
                directionSelect.classList.remove('disabled');
                if (!selectedDirectionId && dirSelectedSpan) {
                    dirSelectedSpan.textContent = 'Выберите направление';
                }
                
                // Авто-подстановка единственного направления
                if (visibleDirectionCount === 1 && !selectedDirectionId && lastVisibleDirectionLi) {
                    lastVisibleDirectionLi.classList.add('selected');
                    if (dirSelectedSpan) {
                        dirSelectedSpan.textContent = lastVisibleDirectionLi.textContent;
                    }
                    selectedDirectionId = lastVisibleDirectionLi.getAttribute('data-value');
                    syncClearableSelectState(directionSelect);
                }
            }

            // 5) Фильтрация преподавателей по выбранному направлению и доступности времени
            var visibleTeacherCount = 0;
            var lastVisibleTeacherLi = null;
            
            teacherLis.forEach(function (li) {
                var teacherId = parseInt(li.getAttribute('data-value'), 10);
                var dirsRaw = li.getAttribute('data-directions') || '';
                var dirs = dirsRaw ? dirsRaw.split(',').map(function (v) { return v.trim(); }).filter(Boolean) : [];
                
                // Фильтр по направлению
                var directionMatch = !selectedDirectionId || dirs.indexOf(String(selectedDirectionId)) !== -1;
                
                // Фильтр по доступности времени
                var timeAvailable = availableTeacherIds.indexOf(teacherId) !== -1;
                
                var isVisible = directionMatch && timeAvailable;
                li.style.display = isVisible ? '' : 'none';
                if (isVisible) {
                    visibleTeacherCount++;
                    lastVisibleTeacherLi = li;
                }
            });
            
            // 6) Обновляем состояние селекта преподавателей
            var teacherSelectedSpan = teacherSelect.querySelector('span.selected');
            if (visibleTeacherCount === 0) {
                // Нет доступных специалистов
                teacherSelect.classList.add('disabled');
                if (teacherSelectedSpan) teacherSelectedSpan.textContent = 'Нет доступных специалистов';
            } else {
                teacherSelect.classList.remove('disabled');
                if (!selectedTeacherId && teacherSelectedSpan) {
                    teacherSelectedSpan.textContent = 'Выберите преподавателя';
                }
                
                // Авто-подстановка единственного специалиста
                if (visibleTeacherCount === 1 && !selectedTeacherId && lastVisibleTeacherLi) {
                    lastVisibleTeacherLi.classList.add('selected');
                    if (teacherSelectedSpan) {
                        teacherSelectedSpan.textContent = lastVisibleTeacherLi.textContent;
                    }
                    selectedTeacherId = lastVisibleTeacherLi.getAttribute('data-value');
                    syncClearableSelectState(teacherSelect);
                    
                    // Если у единственного специалиста одно направление — подставляем его тоже
                    var singleTeacherDirsRaw = lastVisibleTeacherLi.getAttribute('data-directions') || '';
                    var singleTeacherDirs = singleTeacherDirsRaw ? singleTeacherDirsRaw.split(',').map(function (v) { return v.trim(); }).filter(Boolean) : [];
                    if (singleTeacherDirs.length === 1 && !selectedDirectionId) {
                        var singleDirId = singleTeacherDirs[0];
                        directionLis.forEach(function (li) {
                            if (li.getAttribute('data-value') === singleDirId) {
                                li.classList.add('selected');
                                if (dirSelectedSpan) {
                                    dirSelectedSpan.textContent = li.textContent;
                                }
                                syncClearableSelectState(directionSelect);
                            }
                        });
                    }
                }
            }
            
            // 7) Проверка выбранного преподавателя на доступность
            if (selectedTeacherId && checkStartMinutes !== null && checkEndMinutes !== null) {
                var teacherIdInt = parseInt(selectedTeacherId, 10);
                if (window.isSpecialistBusy(teacherIdInt, checkStartMinutes, checkEndMinutes)) {
                    if (teacherWarning) teacherWarning.style.display = 'inline-block';
                } else {
                    if (teacherWarning) teacherWarning.style.display = 'none';
                }
            } else {
                if (teacherWarning) teacherWarning.style.display = 'none';
            }
            
            // Вызываем глобальную функцию для обновления состояния кнопки
            if (typeof window.updateSubmitButtonState === 'function') {
                window.updateSubmitButtonState();
            }
        }
        // Делаем функцию доступной глобально для вызова из других блоков кода
        window.applyTeacherDirectionFilters = applyTeacherDirectionFilters;

        function applyServicesFilters() {
            var servicesSelect = modalElement.querySelector('#services');
            if (!servicesSelect) {
                return;
            }

            var roomIdField = modalElement.querySelector('#roomIdField');
            var currentRoomId = roomIdField ? String(roomIdField.value || '') : '';
            var currentScenarioId = (window.currentScenarioFilterId !== undefined && window.currentScenarioFilterId !== null)
                ? String(window.currentScenarioFilterId)
                : '';

            // Фильтрация + защита от дублей:
            // Если по какой-то причине одинаковые услуги оказались добавлены несколько раз, оставляем только одну.
            // Ключ: service_id + room_id + scenario_id
            var options = servicesSelect.querySelectorAll('ul.options li');
            var seen = new Map();

            Array.from(options).forEach(function (li) {
                var liRoomId = String(li.getAttribute('data-room-id') || '');
                var liScenarioId = String(li.getAttribute('data-scenario-id') || '');
                var liValue = String(li.getAttribute('data-value') || '');

                var dedupeKey = liValue + '|' + liRoomId + '|' + liScenarioId;
                if (seen.has(dedupeKey)) {
                    var kept = seen.get(dedupeKey);

                    // Если выбран дубль, а сохранённый элемент не выбран — переносим выбранность на сохранённый.
                    if (li.classList.contains('selected') && kept && !kept.classList.contains('selected')) {
                        kept.classList.add('selected');

                        if (servicesSelect._selectedOptions) {
                            servicesSelect._selectedOptions.add(kept);
                            servicesSelect._selectedOptions.delete(li);
                        }
                    }

                    if (li.parentNode) {
                        li.parentNode.removeChild(li);
                    }
                    return;
                }
                seen.set(dedupeKey, li);

                var roomOk = !liRoomId || !currentRoomId || liRoomId === currentRoomId;
                var scenarioOk = !liScenarioId || !currentScenarioId || liScenarioId === currentScenarioId;

                li.style.display = (roomOk && scenarioOk) ? '' : 'none';
            });

            if (servicesSelect._selectedOptions && servicesSelect._selectedOptions.size) {
                var changed = false;
                Array.from(servicesSelect._selectedOptions).forEach(function (opt) {
                    if (opt.style.display === 'none') {
                        opt.classList.remove('selected');
                        servicesSelect._selectedOptions.delete(opt);
                        changed = true;
                    }
                });

                if (changed && typeof servicesSelect._updateSelectedText === 'function') {
                    servicesSelect._updateSelectedText();
                }
            }
        }

        applyServicesFilters();

        // --------------------------
        // Инициализация кастомных селектов
        // --------------------------
        var customSelects = Array.from(modalElement.querySelectorAll('.custom-select'));

        // Один глобальный обработчик закрытия по клику вне селекта (без навешивания N одинаковых слушателей)
        document.addEventListener('click', function (e) {
            customSelects.forEach(function (select) {
                if (!select.contains(e.target)) {
                    select.classList.remove('open');
                }
            });
        });

        customSelects.forEach(function (select) {
            var selected = select.querySelector('.selected');
            var optionsContainer = select.querySelector('.options');
            if (!selected || !optionsContainer) {
                return;
            }

            var optionsList = optionsContainer.querySelectorAll('li');
            var isClientSelect = select.id === 'client';
            var searchInput = isClientSelect ? select.querySelector('#client-search-input') : null;
            var searchOption = isClientSelect ? select.querySelector('#search-option') : null;

            var clearBtn = select.querySelector('.custom-select-clear');
            if (clearBtn) {
                clearBtn.addEventListener('click', function (e) {
                    e.preventDefault();
                    e.stopPropagation();

                    teacherDirectionLastChanged = select.id;
                    resetSelect(select);
                    select.classList.remove('open');

                    if (select.id === 'teacher' || select.id === 'field-direction') {
                        applyTeacherDirectionFilters();
                    }
                });
            }

            syncClearableSelectState(select);

            // Множественный выбор только для услуг (список не закрываем при выборе)
            if (select.id === 'services') {
                var selectedOptions = new Set();
                select._selectedOptions = selectedOptions;

                function updateSelectedText() {
                    if (selectedOptions.size === 0) {
                        selected.textContent = 'Выберите услугу';
                    } else if (selectedOptions.size === 1) {
                        selected.textContent = Array.from(selectedOptions)[0].textContent;
                    } else {
                        selected.textContent = selectedOptions.size + ' выбрано';
                    }
                }

                select._updateSelectedText = updateSelectedText;

                select.addEventListener('click', function (e) {
                    if (e.target.tagName !== 'LI') {
                        select.classList.toggle('open');
                    }
                });

                optionsList.forEach(function (option) {
                    option.addEventListener('mousedown', function (e) {
                        e.stopPropagation();
                    });
                    option.addEventListener('click', function (e) {
                        e.stopPropagation();
                        if (option.classList.contains('selected')) {
                            option.classList.remove('selected');
                            selectedOptions.delete(option);
                        } else {
                            option.classList.add('selected');
                            selectedOptions.add(option);
                        }

                        updateSelectedText();
                        
                        // Пересчитываем стоимость брони при изменении услуг
                        if (typeof window.calculateAndUpdateBookingCost === 'function') {
                            window.calculateAndUpdateBookingCost();
                        }
                    });
                });

                return;
            }

            // Поиск по клиентам
            if (isClientSelect && searchInput) {
                searchInput.addEventListener('input', function () {
                    var filter = this.value.trim().toLowerCase();
                    optionsList.forEach(function (option) {
                        if (option.id === 'search-option') {
                            return;
                        }
                        var text = option.textContent.trim().toLowerCase();
                        option.style.display = text.indexOf(filter) !== -1 ? '' : 'none';
                    });
                });

                if (searchOption) {
                    // не даём выбрать пункт с поиском и не закрываем селект при клике по нему
                    searchOption.addEventListener('mousedown', function (e) {
                        e.stopPropagation();
                    });
                    searchOption.addEventListener('click', function (e) {
                        e.stopPropagation();
                    });
                }
            }

            // Обычный одиночный выбор (селект закрывается после выбора)
            select.addEventListener('click', function (e) {
                // не обрабатываем клики по option, они обрабатываются ниже
                if (e.target.tagName !== 'LI') {
                    select.classList.toggle('open');

                    // при открытии списка клиентов ставим фокус в поле поиска
                    if (isClientSelect && searchInput) {
                        setTimeout(function () {
                            searchInput.focus();
                        }, 0);
                    }
                }
            });

            optionsList.forEach(function (option) {
                // в селекте клиентов пункт с инпутом поиска не должен выбираться
                if (option.id === 'search-option') {
                    return;
                }

                option.addEventListener('click', function (e) {
                    e.stopPropagation();
                    optionsList.forEach(function (opt) { opt.classList.remove('selected'); });
                    option.classList.add('selected');
                    selected.textContent = option.textContent;
                    select.classList.remove('open');

                    syncClearableSelectState(select);

                    if (select.id === 'teacher' || select.id === 'field-direction') {
                        teacherDirectionLastChanged = select.id;
                        applyTeacherDirectionFilters();
                    }
                    
                    // Обновляем состояние кнопки "Добавить" при выборе любого селекта
                    if (typeof window.updateSubmitButtonState === 'function') {
                        window.updateSubmitButtonState();
                    }
                });
            });
        });

        // При закрытии модалки сбрасываем связанные селекты и фильтры, чтобы при следующем открытии не оставались скрытые элементы
        modalElement.addEventListener('hidden.bs.modal', function () {
            teacherDirectionLastChanged = null;
            resetTeacherDirectionUI();
        });

        // При открытии гарантируем корректную фильтрацию (на случай, если есть предустановленные значения)
        modalElement.addEventListener('shown.bs.modal', function () {
            applyTeacherDirectionFilters();
            applyServicesFilters();
            
            // Сбрасываем все селекты при открытии модалки
            resetAllSelects();
            
            // Сбрасываем стоимость брони на 0 при открытии
            var costElement = document.getElementById('bookingCostValue');
            if (costElement) {
                costElement.textContent = '0 BYN';
            }
        });
        
        // Функция сброса всех селектов в модалке
        function resetAllSelects() {
            var selectsToReset = ['client', 'teacher', 'field-direction', 'duration', 'start-time', 'end-time'];
            selectsToReset.forEach(function (selectId) {
                var select = document.getElementById(selectId);
                if (!select) return;
                
                // Снимаем selected со всех опций
                var options = select.querySelectorAll('ul.options li');
                options.forEach(function (opt) {
                    if (opt.id !== 'search-option') {
                        opt.classList.remove('selected');
                    }
                });
                
                // Сбрасываем текст на placeholder
                var selectedSpan = select.querySelector('span.selected');
                var placeholder = select.getAttribute('data-placeholder');
                if (selectedSpan) {
                    if (selectId === 'client') {
                        selectedSpan.textContent = 'Выберите клиента';
                    } else if (selectId === 'teacher') {
                        selectedSpan.textContent = 'Выберите преподавателя';
                    } else if (selectId === 'field-direction') {
                        selectedSpan.textContent = 'Выберите направление';
                    } else if (selectId === 'duration') {
                        selectedSpan.textContent = 'Выберите длительность';
                    } else if (selectId === 'start-time') {
                        selectedSpan.textContent = 'Начало';
                    } else if (selectId === 'end-time') {
                        selectedSpan.textContent = 'Конец';
                    } else if (placeholder) {
                        selectedSpan.textContent = placeholder;
                    }
                }
                
                // Обновляем состояние кнопки очистки для clearable селектов
                if (typeof syncClearableSelectState === 'function') {
                    syncClearableSelectState(select);
                }
            });
            
            // Сбрасываем услуги
            var servicesSelect = document.getElementById('services');
            if (servicesSelect && servicesSelect._selectedOptions) {
                servicesSelect._selectedOptions.clear();
                var servicesOptions = servicesSelect.querySelectorAll('ul.options li');
                servicesOptions.forEach(function (opt) {
                    opt.classList.remove('selected');
                });
                var servicesSelectedSpan = servicesSelect.querySelector('span.selected');
                if (servicesSelectedSpan) {
                    servicesSelectedSpan.textContent = 'Выберите услуги';
                }
            }
            
            // Сбрасываем комментарий
            var commentField = document.getElementById('bookingComment');
            if (commentField) {
                commentField.value = '';
            }
            // Сбрасываем счётчик символов
            var commentCounter = document.getElementById('bookingCommentCounter');
            if (commentCounter) {
                commentCounter.textContent = '0/1000';
            }
            
            // Сбрасываем глобальные переменные времени
            window.currentStartTimeMinutes = null;
            window.currentEndTimeMinutes = null;
            window.currentSelectedPeriods = null;
        }

        // --- Обработчик отправки формы создания брони ---
        var submitBtn = document.getElementById('createBookingSubmitBtn');
        if (submitBtn) {
            submitBtn.addEventListener('click', function () {
                submitCreateBookingForm();
            });
        }

        // Функция отправки формы создания брони
        function submitCreateBookingForm() {
            var form = document.getElementById('bookingForm');
            if (!form) return;

            // Собираем данные формы
            var formData = new FormData();

            // CSRF token
            var csrfToken = form.querySelector('[name="csrfmiddlewaretoken"]');
            if (csrfToken) {
                formData.append('csrfmiddlewaretoken', csrfToken.value);
            }

            // Scenario ID (из глобальной переменной)
            if (window.currentScenarioFilterId) {
                formData.append('scenario_id', window.currentScenarioFilterId);
            }

            // Room ID
            var roomIdField = document.getElementById('roomIdField');
            if (roomIdField && roomIdField.value) {
                formData.append('room_id', roomIdField.value);
            }

            // Client ID
            var clientSelect = document.getElementById('client');
            if (clientSelect) {
                var selectedClient = clientSelect.querySelector('ul.options li.selected:not(#search-option)');
                if (selectedClient && selectedClient.getAttribute('data-value')) {
                    formData.append('client_id', selectedClient.getAttribute('data-value'));
                }
            }

            // Specialist ID (преподаватель)
            var teacherSelect = document.getElementById('teacher');
            if (teacherSelect) {
                var selectedTeacher = teacherSelect.querySelector('ul.options li.selected');
                if (selectedTeacher) {
                    formData.append('specialist_id', selectedTeacher.getAttribute('data-value'));
                }
            }

            // Direction ID (направление)
            var directionSelect = document.getElementById('field-direction');
            if (directionSelect) {
                var selectedDirection = directionSelect.querySelector('ul.options li.selected');
                if (selectedDirection) {
                    formData.append('direction_id', selectedDirection.getAttribute('data-value'));
                }
            }

            // Full datetime (дата + время начала)
            var modalDateInput = document.getElementById('modal-create-date');
            var startTime = window.currentStartTimeMinutes;
            if (modalDateInput && modalDateInput.value && startTime !== null && startTime !== undefined) {
                var hours = Math.floor(startTime / 60);
                var mins = startTime % 60;
                var timeStr = String(hours).padStart(2, '0') + ':' + String(mins).padStart(2, '0') + ':00';
                formData.append('full_datetime', modalDateInput.value + ' ' + timeStr);
            }

            // Duration (длительность в формате HH:MM)
            var durationSelect = document.getElementById('duration');
            var startMinutesForDuration = window.currentStartTimeMinutes;
            var endMinutesForDuration = window.currentEndTimeMinutes;
            if (
                startMinutesForDuration !== null && startMinutesForDuration !== undefined &&
                endMinutesForDuration !== null && endMinutesForDuration !== undefined &&
                endMinutesForDuration > startMinutesForDuration
            ) {
                var durationMinutes = endMinutesForDuration - startMinutesForDuration;
                var durationHours = Math.floor(durationMinutes / 60);
                var durationMins = durationMinutes % 60;
                var durationStr = String(durationHours).padStart(2, '0') + ':' + String(durationMins).padStart(2, '0');
                formData.append('duration', durationStr);
            } else if (durationSelect) {
                var selectedDuration = durationSelect.querySelector('ul.options li.selected');
                if (selectedDuration) {
                    var durationStr = selectedDuration.getAttribute('data-value');
                    if (!durationStr) {
                        var periods = parseInt(selectedDuration.getAttribute('data-periods'), 10);
                        var minMinutes = window.getScenarioMinDurationMinutes ? window.getScenarioMinDurationMinutes() : 60;
                        var totalMinutes = periods * minMinutes;
                        var durationHours = Math.floor(totalMinutes / 60);
                        var durationMins = totalMinutes % 60;
                        durationStr = String(durationHours).padStart(2, '0') + ':' + String(durationMins).padStart(2, '0');
                    }
                    formData.append('duration', durationStr);
                }
            }

            // Services (услуги)
            var servicesSelect = document.getElementById('services');
            if (servicesSelect && servicesSelect._selectedOptions) {
                servicesSelect._selectedOptions.forEach(function (li) {
                    var serviceId = li.getAttribute('data-value');
                    if (serviceId) {
                        formData.append('services', serviceId);
                    }
                });
            }

            // Total cost (стоимость)
            var costElement = document.getElementById('bookingCostValue');
            if (costElement) {
                var costText = costElement.textContent.replace(/[^\d.,]/g, '').replace(',', '.');
                if (costText) {
                    formData.append('total_cost', costText);
                }
            }

            // Comment (комментарий)
            var commentField = document.getElementById('bookingComment');
            if (commentField && commentField.value) {
                formData.append('comment', commentField.value);
            }

            // Валидация обязательных полей
            if (!formData.get('client_id')) {
                alert('Выберите клиента');
                return;
            }
            if (!formData.get('full_datetime')) {
                alert('Выберите время начала');
                return;
            }
            if (!formData.get('duration')) {
                alert('Выберите длительность');
                return;
            }

            // Отправка запроса
            var submitBtn = document.getElementById('createBookingSubmitBtn');
            if (submitBtn) {
                submitBtn.disabled = true;
                submitBtn.textContent = 'Сохранение...';
            }

            fetch('/create_booking/', {
                method: 'POST',
                body: formData
            })
            .then(function (response) {
                return response.json();
            })
            .then(function (data) {
                if (data.success) {
                    // Закрываем модалку (данные обновятся автоматически через AJAX)
                    var modal = bootstrap.Modal.getInstance(modalElement);
                    if (modal) {
                        modal.hide();
                    }
                } else {
                    alert('Ошибка: ' + (data.error || 'Неизвестная ошибка'));
                }
            })
            .catch(function (error) {
                alert('Ошибка сети: ' + error.message);
            })
            .finally(function () {
                if (submitBtn) {
                    submitBtn.disabled = false;
                    submitBtn.textContent = 'Добавить';
                }
            });
        }
    })();
</script>