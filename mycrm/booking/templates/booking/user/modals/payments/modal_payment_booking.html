{% load static %}
<div class="modal fade" id="paymentBookingModal" tabindex="-1" aria-labelledby="paymentBookingModalLabel"
    aria-hidden="true" data-bs-backdrop="false">
    <div class="modal-dialog modal-dialog-centered" style="max-width:none; width: 31vw;">
        <div class="modal-content">
            <div class="modal-body">
                <div class="mb-3">
                    <!--Кнопка возврата, заголовок и крестик-->
                    <div class="row d-flex align-items-center mb-5">
                        <div class="col-md-12 d-flex justify-content-between align-items-center">
                            <div class="d-flex justify-content-start align-items-center gap-3">
                                <button type="button" class="button-third" onclick="switchToInfoFromPaymentModal()">
                                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                                        xmlns="http://www.w3.org/2000/svg">
                                        <path d="M12 19L5 12L12 5" stroke="#7A52FF" stroke-width="2" stroke-linecap="round"
                                            stroke-linejoin="round" />
                                        <path d="M19 12H5" stroke="#7A52FF" stroke-width="2" stroke-linecap="round"
                                            stroke-linejoin="round" />
                                    </svg>
                                </button>
                                <h2 class="mb-0">Внесение оплаты</h2>
                            </div>
                            <div class="d-flex align-items-center gap-3">
                                <div id="publicIdContainer" class="d-flex align-items-end">
                                    <span>ID:</span>
                                    <span id="publicID" class="ms-2">123456</span>
                                </div>
                                <button type="button" class="modal-close-icon" onclick="showConfirmCancelModal()"
                                    aria-label="Закрыть">
                                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                                        xmlns="http://www.w3.org/2000/svg">
                                        <path d="M18 6L6 18" stroke="#7A52FF" stroke-width="2" stroke-linecap="round"
                                            stroke-linejoin="round" />
                                        <path d="M6 6L18 18" stroke="#7A52FF" stroke-width="2" stroke-linecap="round"
                                            stroke-linejoin="round" />
                                    </svg>
                                </button>
                            </div>
                        </div>
                    </div>
                    <!--Стоимость / Внесено / Остаток-->
                    <div class="col-md-12 payment-summary mb-5" id="paymentTextContainer">
                        <div class="payment-summary-item">
                            <h4 class="mb-0" id="paymentSummaryTotal">70 BYN</h4>
                            <span class="payment-summary-label">Стоимость</span>
                        </div>
                        <div class="payment-summary-item payment-summary-divider">
                            <h4 class="mb-0">/</h4>
                            <span class="payment-summary-label"></span>
                        </div>
                        <div class="payment-summary-item">
                            <h4 class="mb-0" id="paymentSummaryPaid">0 BYN</h4>
                            <span class="payment-summary-label">Внесено</span>
                        </div>
                        <div class="payment-summary-item payment-summary-divider">
                            <h4 class="mb-0">/</h4>
                            <span class="payment-summary-label"></span>
                        </div>
                        <div class="payment-summary-item">
                            <h4 class="mb-0" id="paymentSummaryRemaining">70 BYN</h4>
                            <span class="payment-summary-label">Остаток</span>
                        </div>
                    </div>
                    <!--Блок внесения оплаты-->
                    <div class="row mb-3">
                        <div class="col-12" id="paymentMethodsContainer"></div>
                        <div class="col-12 mb-4">
                            <button type="button"
                                class="button-third add-payment-method-trigger d-inline-flex align-items-center gap-2"
                                id="addPaymentMethodButton">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                                    xmlns="http://www.w3.org/2000/svg">
                                    <path d="M5 12H19" stroke="#7A52FF" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round" />
                                    <path d="M12 5V19" stroke="#7A52FF" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round" />
                                </svg>
                                <span class="add-payment-method-text">Добавить способ оплаты</span>
                            </button>
                        </div>

                        <template id="paymentMethodBlockTemplate">
                            <div class="payment-method-card mb-4" data-payment-method-block>
                                <div class="row g-4 align-items-end payment-method-row">
                                    <div class="col-lg-9 col-md-8">
                                        <label class="form-label">Способ оплаты</label>
                                        <div class="custom-select payment-method-select" data-payment-select>
                                            <span class="selected">Выберите способ</span>
                                            <span class="chevron">
                                                <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                                                    xmlns="http://www.w3.org/2000/svg">
                                                    <path d="M6 9L12 15L18 9" stroke="#818EA2" stroke-width="2" />
                                                </svg>
                                            </span>
                                            <ul class="options"></ul>
                                        </div>
                                    </div>
                                    <div class="col-lg-3 col-md-4">
                                        <div class="d-flex align-items-center justify-content-between mb-2">
                                            <label class="form-label mb-0">Сумма, BYN</label>
                                            <button type="button" class="payment-method-remove button-third" data-remove-block
                                                aria-label="Удалить способ оплаты">
                                                <svg width="18" height="18" viewBox="0 0 24 24" fill="none"
                                                    xmlns="http://www.w3.org/2000/svg">
                                                    <path d="M18 6L6 18" stroke="#7A52FF" stroke-width="2"
                                                        stroke-linecap="round" stroke-linejoin="round" />
                                                    <path d="M6 6L18 18" stroke="#7A52FF" stroke-width="2"
                                                        stroke-linecap="round" stroke-linejoin="round" />
                                                </svg>
                                            </button>
                                        </div>
                                        <input type="text" class="payment-value-input" data-payment-value
                                            placeholder="99" inputmode="decimal" autocomplete="off" />
                                    </div>
                                </div>
                            </div>
                        </template>

                        <!--Блок Итого-->
                        <div class="col-12 mb-4">
                            <div class="payment-total-wrapper" id="paymentTotalWrapper">
                                <div class="payment-total-text">Итого</div>
                                <div class="payment-total-amount" id="paymentTotalAmount">120 BYN</div>
                            </div>
                        </div>

                        <!--Кнопка "Оплатить"-->
                        <div class="col-md-12 d-flex align-items-center justify-content-center">
                            <button type="button" class="button-primary" id="paymentSubmitButton" disabled>Оплатить</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    // === DOM-узлы и состояние модалки оплаты ===
    const paymentModalElement = document.getElementById('paymentBookingModal');
    const paymentMethodsContainer = document.getElementById('paymentMethodsContainer');
    const addPaymentMethodButton = document.getElementById('addPaymentMethodButton');
    const paymentSubmitButton = document.getElementById('paymentSubmitButton');
    const paymentTotalWrapper = document.getElementById('paymentTotalWrapper');
    const paymentTotalAmount = document.getElementById('paymentTotalAmount');
    // Элементы блока "Стоимость / Внесено / Остаток"
    const paymentSummaryTotalElement = document.getElementById('paymentSummaryTotal');
    const paymentSummaryPaidElement = document.getElementById('paymentSummaryPaid');
    const paymentSummaryRemainingElement = document.getElementById('paymentSummaryRemaining');
    const paymentMethodTemplate = document.getElementById('paymentMethodBlockTemplate');
    let paymentModalForceClose = false;
    let paymentMethodBlocks = [];
    let paymentMethodBlockIdCounter = 0;
    let paymentSelectCloseListenerAttached = false;
    // Остаток к оплате по текущей брони (число), используется как верхний лимит для суммарной оплаты
    let bookingRemainingAmount = null;
    let bookingTotalCostAmount = null;
    let bookingPaidAmount = null;
    let paymentSuccessFlow = false;

    // === Хелперы работы с суммой оплаты ===
    // Очищает ввод до корректного десятичного формата с двумя знаками после разделителя
    // и, при необходимости, ограничивает значение верхней границей maxValue
    function sanitizePaymentValue(value, options = {}) {
        const { preserveSeparator = false, maxValue = null } = options;
        if (!value) return '';

        let sanitized = value.replace(/[^0-9.,]/g, '');
        if (!sanitized) return '';

        const separatorMatch = sanitized.match(/[.,]/);

        const numericMax = typeof maxValue === 'number' ? maxValue : parseFloat(maxValue);
        const hasMax = Number.isFinite(numericMax);
        const effectiveMax = hasMax ? Math.max(0, numericMax) : null;

        if (!separatorMatch) {
            const numericValue = parseFloat(sanitized);
            if (!isNaN(numericValue) && effectiveMax !== null && numericValue > effectiveMax) {
                return effectiveMax.toFixed(2);
            }
            return sanitized;
        }

        const separatorIndex = separatorMatch.index;
        const separator = separatorMatch[0];

        const integerPartRaw = sanitized.slice(0, separatorIndex).replace(/[.,]/g, '');
        const integerPart = integerPartRaw || '0';
        const decimalsRaw = sanitized.slice(separatorIndex + 1).replace(/[.,]/g, '');
        const decimalPart = decimalsRaw.slice(0, 2);

        const visibleSeparator = preserveSeparator ? separator : '.';

        const normalizedValue = decimalPart ? `${integerPart}.${decimalPart}` : integerPart;
        const numericValue = parseFloat(normalizedValue);
        if (!isNaN(numericValue) && effectiveMax !== null && numericValue > effectiveMax) {
            const maxString = effectiveMax.toFixed(2);
            return preserveSeparator && separator === ',' ? maxString.replace('.', ',') : maxString;
        }

        if (!decimalPart && sanitized.endsWith(separator)) {
            return `${integerPart}${visibleSeparator}`;
        }

        return decimalPart ? `${integerPart}${visibleSeparator}${decimalPart}` : integerPart;
    }

    // Преобразует строковое значение суммы в числовой формат (поддерживает точку и запятую)
    function parsePaymentNumericValue(value) {
        if (!value && value !== 0) return NaN;
        const normalized = String(value).replace(',', '.');
        const numeric = parseFloat(normalized);
        return Number.isFinite(numeric) ? numeric : NaN;
    }

    // Подписывает поле ввода на очистку, доводку формата, пересчёт суммы и блокировку стрелок
    function initPaymentValueValidation(input) {
        if (!input || input.dataset.validationAttached === 'true') return;

        input.addEventListener('input', function () {
            const maxForInput = getMaxAllowedValueForInput(input);
            const formatted = sanitizePaymentValue(input.value, { preserveSeparator: true, maxValue: maxForInput });
            input.value = formatted;
            updatePaymentSubmitButtonState();
            updateTotalAmount();
        });

        input.addEventListener('blur', function () {
            if (!input.value) {
                updatePaymentSubmitButtonState();
                updateTotalAmount();
                return;
            }

            const maxForInput = getMaxAllowedValueForInput(input);
            let formatted = sanitizePaymentValue(input.value, { maxValue: maxForInput });
            if (formatted.startsWith('.')) {
                formatted = `0${formatted}`;
            }
            if (formatted.endsWith('.')) {
                formatted = formatted.slice(0, -1);
            }
            const numericValue = parsePaymentNumericValue(formatted);
            if (!numericValue || numericValue <= 0) {
                input.value = '';
                updatePaymentSubmitButtonState();
                updateTotalAmount();
                return;
            }

            input.value = formatted;
            updatePaymentSubmitButtonState();
            updateTotalAmount();
        });

        input.addEventListener('keydown', function (event) {
            if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {
                event.preventDefault();
            }
        });

        input.dataset.validationAttached = 'true';
    }

    // Проверяет, что в блоке оплаты введена корректная положительная сумма
    function isPaymentBlockValueValid(block) {
        if (!block || !block.paymentInput) return false;
        const numericValue = parsePaymentNumericValue(block.paymentInput.value);
        return Number.isFinite(numericValue) && numericValue > 0;
    }

    // Блок считается заполненным, если выбран тип оплаты и введена валидная сумма
    function isPaymentBlockComplete(block) {
        return block.selectedPaymentTypeId && isPaymentBlockValueValid(block);
    }

    // Все ли блоки оплаты заполнены полностью
    function allPaymentBlocksValid() {
        if (!paymentMethodBlocks.length) return false;
        return paymentMethodBlocks.every(block => isPaymentBlockComplete(block));
    }

    // Управляет доступностью кнопки "Оплатить" в зависимости от валидности блоков (кнопка не скрывается)
    function updatePaymentSubmitButtonState() {
        if (!paymentSubmitButton) return;
        const shouldEnable = allPaymentBlocksValid();
        paymentSubmitButton.disabled = !shouldEnable;
    }

    // Показывает/скрывает блок "Итого" в зависимости от количества способов оплаты
    function updateTotalBlockVisibility() {
        if (!paymentTotalWrapper) return;
        const shouldShow = paymentMethodBlocks.length > 1;
        paymentTotalWrapper.classList.toggle('d-none', !shouldShow);
    }

    // Пересчитывает общую сумму по всем блокам и обновляет значение в блоке "Итого"
    function updateTotalAmount() {
        if (!paymentTotalAmount) return;

        let total = 0;
        paymentMethodBlocks.forEach(block => {
            if (!block || !block.paymentInput) return;
            const value = parsePaymentNumericValue(block.paymentInput.value);
            if (Number.isFinite(value) && value > 0) {
                total += value;
            }
        });

        const formatted = total.toFixed(2);
        paymentTotalAmount.textContent = `${formatted} BYN`;

        updatePaymentSummaryWithInputs();
    }

    // Возвращает суммарную текущую сумму по всем полям оплат (с опцией исключить одно поле)
    function getCurrentPaymentsTotal(excludeInput = null) {
        let total = 0;
        paymentMethodBlocks.forEach(block => {
            if (!block || !block.paymentInput) return;
            if (excludeInput && block.paymentInput === excludeInput) return;
            const value = parsePaymentNumericValue(block.paymentInput.value);
            if (Number.isFinite(value) && value > 0) {
                total += value;
            }
        });
        return total;
    }

    // Для конкретного поля ввода возвращает максимально допустимое значение с учётом остатка и других полей
    function getMaxAllowedValueForInput(input) {
        if (!input) return null;
        if (!Number.isFinite(bookingRemainingAmount)) {
            // Если остаток ещё не загружен, не ограничиваем ввод дополнительно
            return null;
        }

        const otherBlocksTotal = getCurrentPaymentsTotal(input);
        const maxForThis = bookingRemainingAmount - otherBlocksTotal;
        return maxForThis >= 0 ? maxForThis : 0;
    }

    // Форматирует числовое значение в строку вида "70" или "70.50 BYN"
    function formatAmountByn(value) {
        const numeric = parsePaymentNumericValue(value);
        if (!Number.isFinite(numeric) || numeric < 0) {
            return '0 BYN';
        }

        const isInteger = Number.isInteger(numeric);
        const formatted = isInteger ? numeric.toFixed(0) : numeric.toFixed(2);
        return `${formatted} BYN`;
    }

    // Обновляет блок "Стоимость / Внесено / Остаток" по данным брони с сервера
    function updatePaymentSummaryFromBookingData(bookingData) {
        if (!bookingData) return;

        if (paymentModalElement) {
            const publicIdEl = paymentModalElement.querySelector('#publicID');
            if (publicIdEl && (typeof bookingData.id === 'number' || typeof bookingData.id === 'string')) {
                publicIdEl.textContent = bookingData.id;
            }
        }

        const totalNumeric = parsePaymentNumericValue(bookingData.total_cost);
        bookingTotalCostAmount = Number.isFinite(totalNumeric) ? Math.max(0, totalNumeric) : 0;
        const paidNumeric = parsePaymentNumericValue(bookingData.paid_amount);
        bookingPaidAmount = Number.isFinite(paidNumeric) ? Math.max(0, paidNumeric) : 0;

        if (paymentSummaryTotalElement) {
            paymentSummaryTotalElement.textContent = formatAmountByn(bookingTotalCostAmount);
        }
        if (paymentSummaryPaidElement) {
            paymentSummaryPaidElement.textContent = formatAmountByn(bookingPaidAmount);
        }
        if (paymentSummaryRemainingElement) {
            paymentSummaryRemainingElement.textContent = formatAmountByn(bookingData.remaining_amount);
        }

        // Сохраняем числовое значение остатка для дальнейшего ограничения сумм оплат
        const remainingNumeric = parsePaymentNumericValue(bookingData.remaining_amount);
        bookingRemainingAmount = Number.isFinite(remainingNumeric) ? Math.max(0, remainingNumeric) : 0;

        updatePaymentSummaryWithInputs();
    }

    function updatePaymentSummaryWithInputs() {
        if (!paymentSummaryPaidElement && !paymentSummaryRemainingElement) return;
        if (!Number.isFinite(bookingTotalCostAmount) || !Number.isFinite(bookingPaidAmount)) return;

        const inputTotal = getCurrentPaymentsTotal();
        const paidWithInput = bookingPaidAmount + inputTotal;
        const remainingWithInput = Math.max(0, bookingTotalCostAmount - paidWithInput);

        if (paymentSummaryPaidElement) {
            paymentSummaryPaidElement.textContent = formatAmountByn(paidWithInput);
        }
        if (paymentSummaryRemainingElement) {
            paymentSummaryRemainingElement.textContent = formatAmountByn(remainingWithInput);
        }
    }

    // Загружает детали брони по текущему bookingId и обновляет блок "Стоимость / Внесено / Остаток"
    async function loadPaymentSummaryForCurrentBooking() {
        const bookingId = window.currentBookingId;
        if (!bookingId) {
            console.warn('Не удалось загрузить данные оплаты: не задан currentBookingId');
            return;
        }

        try {
            const response = await fetch(`/booking/get-booking-details/${bookingId}/`);
            if (!response.ok) {
                console.error('Не удалось получить детали брони для оплаты:', response.status);
                return;
            }

            const data = await response.json();
            if (!data.success || !data.booking) {
                console.error('Некорректный ответ при загрузке деталей брони для оплаты:', data);
                return;
            }

            updatePaymentSummaryFromBookingData(data.booking);

            if (Array.isArray(paymentMethodBlocks) && paymentMethodBlocks.length) {
                paymentMethodBlocks.forEach(block => {
                    if (!block || !block.paymentInput) return;
                    const maxForInput = getMaxAllowedValueForInput(block.paymentInput);
                    if (maxForInput === null || maxForInput === undefined) return;
                    const formatted = sanitizePaymentValue(block.paymentInput.value, { preserveSeparator: true, maxValue: maxForInput });
                    block.paymentInput.value = formatted;
                });
                updatePaymentSubmitButtonState();
                updateTotalAmount();
            }
        } catch (error) {
            console.error('Ошибка при загрузке деталей брони для оплаты:', error);
        }
    }

    // Возвращает текст кнопки "Оплатить" в исходное состояние
    function resetSubmitButtonLabel() {
        if (!paymentSubmitButton) return;
        paymentSubmitButton.textContent = 'Оплатить';
    }

    // === Сбор и отправка платежей ===
    // Собирает данные по всем заполненным блокам для отправки на сервер
    function collectPaymentsData() {
        return paymentMethodBlocks
            .filter(block => block.selectedPaymentTypeId && isPaymentBlockValueValid(block))
            .map(block => ({
                payment_type_id: parseInt(block.selectedPaymentTypeId, 10),
                amount: parsePaymentNumericValue(block.paymentInput.value),
            }));
    }

    // Отправляет платежи на сервер и управляет состоянием UI во время/после запроса
    async function submitPayments() {
        const bookingId = window.currentBookingId;
        if (!bookingId) {
            console.error('Не задан ID брони');
            alert('Ошибка: не удалось определить бронь');
            return;
        }

        const paymentsData = collectPaymentsData();
        if (!paymentsData.length) {
            alert('Нет данных для оплаты');
            return;
        }

        // Дополнительная защита: суммарная сумма всех введённых оплат не должна превышать остаток по брони
        if (Number.isFinite(bookingRemainingAmount) && bookingRemainingAmount >= 0) {
            const totalNewPayments = paymentsData.reduce((sum, payment) => {
                const value = typeof payment.amount === 'number' ? payment.amount : parseFloat(payment.amount);
                return Number.isFinite(value) && value > 0 ? sum + value : sum;
            }, 0);

            if (totalNewPayments - bookingRemainingAmount > 0.000001) {
                alert('Суммарная сумма оплат не может превышать остаток к оплате по брони');
                return;
            }
        }

        paymentSubmitButton.disabled = true;
        paymentSubmitButton.textContent = 'Сохранение...';

        try {
            const response = await fetch(`/booking/process-batch-payments/${bookingId}/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ payments: paymentsData }),
            });

            const result = await response.json();

            if (result.success) {
                resetSubmitButtonLabel();
                paymentSuccessFlow = true;
                paymentModalForceClose = true;
                hidePaymentModal();
            } else {
                alert(result.error || 'Ошибка при сохранении платежей');
                paymentSubmitButton.disabled = false;
                paymentSubmitButton.textContent = 'Оплатить';
            }
        } catch (error) {
            console.error('Ошибка при отправке платежей:', error);
            alert('Ошибка сети при сохранении платежей');
            paymentSubmitButton.disabled = false;
            paymentSubmitButton.textContent = 'Оплатить';
        }
    }

    // === Работа со списком типов оплаты ===
    // Возвращает список доступных типов оплаты из глобальной переменной
    function getPaymentTypes() {
        return Array.isArray(window.PAYMENT_TYPES) ? window.PAYMENT_TYPES : [];
    }

    // Следит за кликом вне кастомных селектов, чтобы закрывать открытые выпадающие списки
    function ensurePaymentSelectCloseListener() {
        if (paymentSelectCloseListenerAttached) return;

        if (window.BookingSelectsUtils && typeof window.BookingSelectsUtils.ensureCloseOnOutsideClick === 'function') {
            window.BookingSelectsUtils.ensureCloseOnOutsideClick({
                key: 'paymentBookingModal',
                rootEl: paymentModalElement
            });
            paymentSelectCloseListenerAttached = true;
            return;
        }

        document.addEventListener('click', function (event) {
            document.querySelectorAll('#paymentBookingModal .custom-select.open').forEach(select => {
                if (!select.contains(event.target)) {
                    select.classList.remove('open');
                }
            });
        });
        paymentSelectCloseListenerAttached = true;
    }

    // Возвращает id уже выбранных типов оплаты (для исключения дубликатов в других блоках)
    function getSelectedPaymentTypeIds(excludeBlockId = null) {
        return paymentMethodBlocks
            .filter(block => block.id !== excludeBlockId && block.selectedPaymentTypeId)
            .map(block => block.selectedPaymentTypeId);
    }

    // Устанавливает выбранный тип оплаты для конкретного блока и пересчитывает связанные элементы
    function setBlockSelectedPaymentType(block, type) {
        if (!block || !type) return;
        block.selectedPaymentTypeId = String(type.id);
        if (block.selectedDisplay) {
            block.selectedDisplay.textContent = type.name;
        }
        if (block.selectElement) {
            block.selectElement.classList.remove('open');
        }
        refreshAllSelectOptions(block.id);
        updateAddButtonState();
        updatePaymentSubmitButtonState();
    }

    // Перестраивает список опций конкретного блока с учётом уже занятых типов в других блоках
    function renderPaymentSelectOptions(block) {
        if (!block || !block.optionsContainer || !block.selectedDisplay) return;

        const paymentTypes = getPaymentTypes();
        const selectedIds = getSelectedPaymentTypeIds(block.id);
        const currentSelectedId = block.selectedPaymentTypeId;

        block.optionsContainer.innerHTML = '';

        if (!paymentTypes.length) {
            block.selectedDisplay.textContent = 'Нет доступных способов';
            block.selectElement?.classList.add('disabled');
            return;
        }

        const availableTypes = paymentTypes.filter(type => {
            const typeId = String(type.id);
            return typeId === currentSelectedId || !selectedIds.includes(typeId);
        });

        if (!availableTypes.length && !currentSelectedId) {
            block.selectedDisplay.textContent = 'Нет доступных способов';
            block.selectElement?.classList.add('disabled');
            return;
        }

        block.selectElement?.classList.remove('disabled');

        availableTypes.forEach(type => {
            const option = document.createElement('li');
            option.dataset.value = String(type.id);
            option.textContent = type.name;
            if (String(type.id) === currentSelectedId) {
                option.classList.add('selected');
            }
            block.optionsContainer.appendChild(option);
        });

        if (currentSelectedId) {
            const currentType = paymentTypes.find(type => String(type.id) === currentSelectedId);
            block.selectedDisplay.textContent = currentType ? currentType.name : 'Выберите способ';
        } else {
            block.selectedDisplay.textContent = 'Выберите способ';
        }
    }

    // Синхронизирует все выпадающие списки при выборе/удалении типов оплаты
    function refreshAllSelectOptions(skipBlockId = null) {
        paymentMethodBlocks.forEach(block => {
            if (skipBlockId && block.id === skipBlockId) return;
            renderPaymentSelectOptions(block);
        });
    }

    // Управляет отображением крестиков удаления: скрыт только на первом блоке
    function updateRemoveButtonsState() {
        paymentMethodBlocks.forEach((block, index) => {
            if (!block.removeButton) return;
            if (index === 0) {
                block.removeButton.classList.add('d-none');
            } else {
                block.removeButton.classList.remove('d-none');
            }
        });
    }

    // Проверяет, можно ли добавить ещё блоков (ограничение = количество PaymentType)
    function canAddMorePaymentBlocks() {
        const paymentTypes = getPaymentTypes();
        return paymentTypes.length > 0 && paymentMethodBlocks.length < paymentTypes.length;
    }

    // Прячет/показывает кнопку "Добавить способ" в зависимости от лимита и заполненности блоков
    function updateAddButtonState() {
        if (!addPaymentMethodButton) return;
        const canAdd = canAddMorePaymentBlocks();
        const allBlocksHaveSelection = paymentMethodBlocks.length > 0 && paymentMethodBlocks.every(block => !!block.selectedPaymentTypeId);
        const shouldShowButton = canAdd && allBlocksHaveSelection;

        addPaymentMethodButton.classList.toggle('d-none', !shouldShowButton);
        addPaymentMethodButton.setAttribute('aria-disabled', shouldShowButton ? 'false' : 'true');
        if (!shouldShowButton) {
            addPaymentMethodButton.blur();
        }
    }

    // Удаляет блок оплаты и пересчитывает доступные опции/кнопки/итого
    function removePaymentMethodBlock(blockId) {
        const blockIndex = paymentMethodBlocks.findIndex(block => block.id === blockId);
        if (blockIndex === -1) return;
        const [block] = paymentMethodBlocks.splice(blockIndex, 1);
        if (block?.element && block.element.parentNode) {
            block.element.parentNode.removeChild(block.element);
        }

        if (!paymentMethodBlocks.length) {
            addPaymentMethodBlock();
        } else {
            updateRemoveButtonsState();
            refreshAllSelectOptions();
        }

        updateAddButtonState();
        updatePaymentSubmitButtonState();
        updateTotalBlockVisibility();
        updateTotalAmount();
    }

    // Создаёт новый блок "способ + сумма" из template и подключает все обработчики
    function createPaymentMethodBlock() {
        if (!paymentMethodsContainer || !paymentMethodTemplate) return null;
        const fragment = paymentMethodTemplate.content.cloneNode(true);
        const blockElement = fragment.querySelector('[data-payment-method-block]');
        if (!blockElement) return null;

        const selectElement = blockElement.querySelector('[data-payment-select]');
        const selectedDisplay = selectElement ? selectElement.querySelector('.selected') : null;
        const optionsContainer = selectElement ? selectElement.querySelector('.options') : null;
        const removeButton = blockElement.querySelector('[data-remove-block]');
        const paymentInput = blockElement.querySelector('[data-payment-value]');

        const blockId = `payment-method-${++paymentMethodBlockIdCounter}`;
        blockElement.dataset.paymentMethodBlockId = blockId;

        const blockData = {
            id: blockId,
            element: blockElement,
            selectElement,
            selectedDisplay,
            optionsContainer,
            removeButton,
            paymentInput,
            selectedPaymentTypeId: null,
        };

        if (removeButton) {
            removeButton.addEventListener('click', () => removePaymentMethodBlock(blockId));
        }

        if (selectElement) {
            const closeAll = function () {
                if (!paymentModalElement) return;
                paymentModalElement.querySelectorAll('.custom-select.open').forEach(function (s) {
                    s.classList.remove('open');
                });
            };

            if (window.BookingSelectsUtils && typeof window.BookingSelectsUtils.bindSingleSelect === 'function') {
                window.BookingSelectsUtils.bindSingleSelect({
                    selectEl: selectElement,
                    closeAll: closeAll,
                    closeOthersOnOpen: true,
                    onSelected: function (ctx) {
                        const selectedId = ctx ? (ctx.value || '') : '';
                        const paymentTypes = getPaymentTypes();
                        const type = paymentTypes.find(t => String(t.id) === String(selectedId));
                        if (type) {
                            setBlockSelectedPaymentType(blockData, type);
                        }
                    }
                });
            }
        }

        if (paymentInput) {
            initPaymentValueValidation(paymentInput);
        }

        paymentMethodsContainer.appendChild(blockElement);
        paymentMethodBlocks.push(blockData);
        renderPaymentSelectOptions(blockData);
        updateRemoveButtonsState();
        updateAddButtonState();
        updatePaymentSubmitButtonState();
        updateTotalBlockVisibility();
        updateTotalAmount();

        return blockData;
    }

    // Обработчик добавления нового блока оплаты по кнопке "Добавить способ"
    function addPaymentMethodBlock() {
        if (!canAddMorePaymentBlocks()) return;
        createPaymentMethodBlock();
    }

    // Поддерживает добавление блока оплаты по клику и по клавиатуре
    function handleAddPaymentMethod(event) {
        if (event) {
            event.preventDefault();
        }
        addPaymentMethodBlock();
    }

    // Первичная инициализация блоков при открытии модалки (очистка и создание первого блока)
    function initializePaymentMethodsUI() {
        if (!paymentMethodsContainer) return;

        paymentMethodsContainer.innerHTML = '';
        paymentMethodBlocks = [];
        paymentMethodBlockIdCounter = 0;

        const paymentTypes = getPaymentTypes();

        if (!paymentTypes.length) {
            paymentMethodsContainer.innerHTML = '<div class="payment-methods-empty">Нет доступных способов оплаты</div>';
            if (addPaymentMethodButton) {
                addPaymentMethodButton.classList.add('d-none');
            }
            updateTotalBlockVisibility();
            updateTotalAmount();
            return;
        }

        const block = createPaymentMethodBlock();
        if (block) {
            block.element.classList.add('mb-4');
        }
        updateAddButtonState();
        updatePaymentSubmitButtonState();
        resetSubmitButtonLabel();
        updateTotalAmount();
    }

    // Возвращает DOM-элемент модалки подтверждения отмены действий в оплате
    function getConfirmCancelModalElement() {
        return document.getElementById('confirmCancelActionModal');
    }

    // Включает/выключает оверлей подтверждения для модалки оплаты
    function setPaymentModalConfirmOverlay(active) {
        if (!paymentModalElement) return;
        paymentModalElement.classList.toggle('confirm-cancel-active', active);
    }

    // Показывает модалку подтверждения отмены из модалки оплаты
    function showConfirmCancelModal() {
        const confirmCancelModalElement = getConfirmCancelModalElement();
        if (!confirmCancelModalElement) return;
        attachConfirmModalListeners();
        setPaymentModalConfirmOverlay(true);
        const confirmModal = bootstrap.Modal.getOrCreateInstance(confirmCancelModalElement);
        confirmModal.show();
    }

    // Закрывает модалку оплаты (без показа модалки подтверждения)
    function hidePaymentModal() {
        if (!paymentModalElement) return;
        setPaymentModalConfirmOverlay(false);
        const paymentInstance = bootstrap.Modal.getInstance(paymentModalElement);
        if (paymentInstance) paymentInstance.hide();
    }

    // Однократно навешивает обработчики на модалку подтверждения отмены
    function attachConfirmModalListeners() {
        const confirmCancelModalElement = getConfirmCancelModalElement();
        if (!confirmCancelModalElement || confirmCancelModalElement.dataset.confirmListenerAttached === 'true') return;

        confirmCancelModalElement.addEventListener('hidden.bs.modal', function () {
            if (!paymentModalForceClose) {
                setPaymentModalConfirmOverlay(false);
            }
        });

        confirmCancelModalElement.dataset.confirmListenerAttached = 'true';
    }

    // Закрытие модального окна оплаты и открытие модального окна информации по кнопке "назад"
    function switchToInfoFromPaymentModal() {
        showConfirmCancelModal();
    }

    // Позволяет сторонним сценариям (например, после успешной оплаты) закрыть модалку без подтверждения
    window.paymentModalAllowClose = function () {
        paymentModalForceClose = true;
    };

    // Реагирует на внешнее событие подтверждения отмены и закрывает модалку оплаты
    document.addEventListener('booking:confirm-cancel-action', function () {
        paymentModalForceClose = true;
        const confirmCancelModalElement = getConfirmCancelModalElement();
        if (confirmCancelModalElement) {
            const confirmInstance = bootstrap.Modal.getInstance(confirmCancelModalElement);
            if (confirmInstance) confirmInstance.hide();
        }
        hidePaymentModal();
    });

    // Инициализация логики модалки оплаты
    function initPaymentModalScripts() {
        attachConfirmModalListeners();
        ensurePaymentSelectCloseListener();

        if (addPaymentMethodButton && addPaymentMethodButton.dataset.listenerAttached !== 'true') {
            addPaymentMethodButton.addEventListener('click', handleAddPaymentMethod);
            addPaymentMethodButton.addEventListener('keypress', (event) => {
                if (event.key === 'Enter' || event.key === ' ') {
                    event.preventDefault();
                    handleAddPaymentMethod();
                }
            });
            addPaymentMethodButton.dataset.listenerAttached = 'true';
        }

        // Обработчик кнопки «Оплатить»
        if (paymentSubmitButton && paymentSubmitButton.dataset.listenerAttached !== 'true') {
            paymentSubmitButton.addEventListener('click', submitPayments);
            paymentSubmitButton.dataset.listenerAttached = 'true';
        }

        updatePaymentSubmitButtonState();
    }

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initPaymentModalScripts);
    } else {
        initPaymentModalScripts();
    }

    if (paymentModalElement) {
        paymentModalElement.addEventListener('hide.bs.modal', function (event) {
            if (!paymentModalForceClose) {
                event.preventDefault();
                showConfirmCancelModal();
                return;
            }
            paymentModalForceClose = false;
        });

        paymentModalElement.addEventListener('hidden.bs.modal', function () {
            const reopenInfoModal = function () {
                if (typeof openInfoModal === 'function') {
                    openInfoModal();
                    return;
                }
                const infoEl = document.getElementById('infoBookingModal');
                if (!infoEl) return;
                const infoModal = new bootstrap.Modal(infoEl);
                infoModal.show();
            };

            if (!paymentSuccessFlow) {
                reopenInfoModal();
                return;
            }

            paymentSuccessFlow = false;
            const successEl = document.getElementById('bookingAddedSuccessModal');
            if (!successEl || typeof window.openBookingSuccessModal !== 'function') {
                reopenInfoModal();
                return;
            }
            const onSuccessClosed = function () {
                successEl.removeEventListener('hidden.bs.modal', onSuccessClosed);
                reopenInfoModal();
            };
            successEl.addEventListener('hidden.bs.modal', onSuccessClosed);

            window.openBookingSuccessModal('Оплата успешно внесена');
        });

        paymentModalElement.addEventListener('shown.bs.modal', function () {
            bookingRemainingAmount = null;
            initializePaymentMethodsUI();
            loadPaymentSummaryForCurrentBooking();
        });
    }
</script>